<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Donuland Management System v2.1</title>
    <style>
        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box; 
        }
        
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
            min-height: 100vh; 
        }
        
        .container { 
            max-width: 1400px; 
            margin: 0 auto; 
            background: white; 
            min-height: 100vh; 
            display: flex; 
            flex-direction: column; 
        }
        
        .header { 
            background: linear-gradient(135deg, #ff6b6b, #4ecdc4); 
            padding: 20px 30px; 
            color: white; 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            box-shadow: 0 2px 10px rgba(0,0,0,0.1); 
        }
        
        .header h1 { 
            font-size: 2em; 
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3); 
        }
        
        .header-controls { 
            display: flex; 
            align-items: center; 
            gap: 20px; 
        }
        
        .sync-status { 
            display: flex; 
            align-items: center; 
            gap: 10px; 
            background: rgba(255,255,255,0.2); 
            padding: 8px 15px; 
            border-radius: 20px; 
            backdrop-filter: blur(10px); 
            font-size: 0.9em; 
        }
        
        .status-indicator { 
            width: 12px; 
            height: 12px; 
            border-radius: 50%; 
            background: #f39c12; 
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .nav-tabs { 
            display: flex; 
            background: #f8f9fa; 
            border-bottom: 1px solid #e9ecef; 
            padding: 0 30px; 
            overflow-x: auto; 
        }
        
        .nav-tab { 
            padding: 15px 25px; 
            cursor: pointer; 
            border-bottom: 3px solid transparent; 
            transition: all 0.3s ease; 
            font-weight: 600; 
            color: #6c757d; 
            white-space: nowrap; 
        }
        
        .nav-tab:hover { 
            background: #e9ecef; 
            color: #495057; 
        }
        
        .nav-tab.active { 
            color: #3498db; 
            border-bottom-color: #3498db; 
            background: white; 
        }
        
        .content-area { 
            flex: 1; 
            padding: 30px; 
            overflow-y: auto; 
        }
        
        .tab-content { 
            display: none; 
        }
        
        .tab-content.active { 
            display: block; 
        }
        .form-section { 
            background: #f8f9fa; 
            padding: 25px; 
            border-radius: 10px; 
            border-left: 4px solid #3498db; 
            margin-bottom: 20px;
            position: relative;
        }
        
        .form-section h3 { 
            color: #2c3e50; 
            margin-bottom: 20px; 
            font-size: 1.3em; 
        }
        
        .form-group { 
            margin-bottom: 20px; 
            position: relative; 
        }
        
        .form-group label { 
            display: block; 
            font-weight: 600; 
            color: #34495e; 
            margin-bottom: 8px; 
        }
        
        .form-group input, .form-group select { 
            width: 100%; 
            padding: 12px 15px; 
            border: 2px solid #ddd; 
            border-radius: 8px; 
            font-size: 1em; 
            transition: border-color 0.3s ease; 
        }
        
        .form-group input:focus, .form-group select:focus { 
            outline: none; 
            border-color: #3498db; 
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1); 
        }

        .autocomplete-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #ddd;
            border-top: none;
            border-radius: 0 0 8px 8px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .autocomplete-item {
            padding: 10px 15px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
            transition: background-color 0.2s;
        }

        .autocomplete-item:hover, .autocomplete-item.selected {
            background-color: #f8f9fa;
        }

        .autocomplete-item:last-child {
            border-bottom: none;
        }
        
        .form-row { 
            display: grid; 
            grid-template-columns: 1fr 1fr; 
            gap: 15px; 
        }
        
        .btn { 
            padding: 12px 24px; 
            border: none; 
            border-radius: 8px; 
            cursor: pointer; 
            font-weight: 600; 
            transition: all 0.3s ease; 
            text-decoration: none; 
            display: inline-block; 
            text-align: center; 
            font-size: 0.95em;
        }
        
        .btn-primary { 
            background: linear-gradient(135deg, #3498db, #2980b9); 
            color: white; 
        }
        
        .btn-primary:hover { 
            transform: translateY(-2px); 
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3); 
        }
        
        .btn-success {
            background: linear-gradient(135deg, #27ae60, #219a52);
            color: white;
        }
        
        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(39, 174, 96, 0.3);
        }

        .btn-warning {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            color: white;
        }

        .btn-warning:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(243, 156, 18, 0.3);
        }

        .btn-danger {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
        }

        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(231, 76, 60, 0.3);
        }
        
        .btn-large { 
            font-size: 1.2em; 
            padding: 15px 30px; 
        }

        .input-hint {
            font-size: 0.85em;
            color: #7f8c8d;
            margin-top: 4px;
        }

        .form-group.has-error input,
        .form-group.has-error select {
            border-color: #e74c3c;
            box-shadow: 0 0 0 3px rgba(231, 76, 60, 0.1);
        }

        .form-group.has-success input,
        .form-group.has-success select {
            border-color: #27ae60;
            box-shadow: 0 0 0 3px rgba(39, 174, 96, 0.1);
        }

        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Enhanced Weather Section */
        .weather-section {
            background: linear-gradient(135deg, #74b9ff, #0984e3);
            color: white;
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
            box-shadow: 0 4px 15px rgba(116, 185, 255, 0.3);
        }

        .weather-section h4 {
            margin: 0 0 15px 0;
            font-size: 1.2em;
            font-weight: 600;
        }

        .weather-display {
            background: rgba(255, 255, 255, 0.15);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            backdrop-filter: blur(10px);
        }

        .weather-display h5 {
            margin: 0 0 10px 0;
            font-size: 1.1em;
            font-weight: 600;
        }

        .weather-display p {
            margin: 5px 0;
            font-size: 0.95em;
        }

        .weather-loading {
            text-align: center;
            padding: 15px;
            font-style: italic;
            opacity: 0.9;
        }

        .weather-days {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        .weather-day {
            background: rgba(255, 255, 255, 0.2);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            min-width: 120px;
            flex: 1;
            backdrop-filter: blur(5px);
            transition: all 0.3s ease;
        }

        .weather-day:hover {
            transform: translateY(-2px);
            background: rgba(255, 255, 255, 0.25);
        }

        .weather-day.positive {
            border-left: 4px solid #00b894;
        }

        .weather-day.warning {
            border-left: 4px solid #fdcb6e;
        }

        .weather-day.negative {
            border-left: 4px solid #e17055;
        }

        .weather-day.quality-risk {
            border: 2px solid #e74c3c;
            background: rgba(231, 76, 60, 0.2);
        }

        .weather-day div {
            margin: 3px 0;
            font-size: 0.9em;
        }

        .weather-day strong {
            font-size: 1em;
            font-weight: 600;
        }

        .quality-warning {
            background: rgba(231, 76, 60, 0.15);
            border: 1px solid #e74c3c;
            padding: 10px;
            border-radius: 6px;
            margin-top: 10px;
            color: #c0392b;
            font-weight: 600;
        }
        
        /* Enhanced Prediction Section */
        .prediction-section {
            background: linear-gradient(135deg, #a29bfe, #6c5ce7);
            color: white;
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
            box-shadow: 0 4px 15px rgba(162, 155, 254, 0.3);
        }

        .prediction-section h4 {
            margin: 0 0 20px 0;
            font-size: 1.2em;
            font-weight: 600;
        }

        .business-model-selection {
            background: rgba(255, 255, 255, 0.15);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
        }

        .radio-group {
            display: flex;
            gap: 15px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .radio-group label {
            background: rgba(255, 255, 255, 0.2);
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
        }

        .radio-group label:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: translateY(-1px);
        }

        .radio-group input[type="radio"] {
            margin-right: 8px;
        }

        .financial-params {
            background: rgba(255, 255, 255, 0.15);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
        }

        .param-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            gap: 10px;
        }

        .param-row label {
            flex: 1;
            font-size: 0.95em;
        }

        .param-row input, .param-row select {
            width: 150px;
            padding: 6px 10px;
            border: none;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
        }

        .prediction-results {
            background: rgba(255, 255, 255, 0.15);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
        }

        .prediction-loading {
            text-align: center;
            padding: 15px;
            font-style: italic;
            opacity: 0.9;
        }

        .prediction-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .prediction-metric {
            text-align: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            backdrop-filter: blur(5px);
        }

        .metric-value {
            font-size: 1.8em;
            font-weight: bold;
            line-height: 1.1;
        }

        .metric-label {
            font-size: 0.85em;
            opacity: 0.9;
            margin-top: 5px;
        }

        .confidence-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 8px;
        }

        .confidence-fill {
            height: 100%;
            transition: width 0.5s ease;
        }

        .confidence-fill.confidence-high {
            background: #00b894;
        }

        .confidence-fill.confidence-medium {
            background: #fdcb6e;
        }

        .confidence-fill.confidence-low {
            background: #e17055;
        }
        /* Weekly Planning Section */
        .weekly-planning-section {
            background: linear-gradient(135deg, #fd79a8, #e84393);
            color: white;
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
            box-shadow: 0 4px 15px rgba(253, 121, 168, 0.3);
        }

        .weekly-overview {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .week-metric {
            background: rgba(255, 255, 255, 0.15);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            backdrop-filter: blur(10px);
        }

        .week-metric-value {
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .week-metric-label {
            font-size: 0.9em;
            opacity: 0.9;
        }

        .inventory-alert {
            background: rgba(231, 76, 60, 0.2);
            border: 1px solid #e74c3c;
            padding: 12px;
            border-radius: 6px;
            margin: 10px 0;
            color: #c0392b;
        }

        .inventory-ok {
            background: rgba(39, 174, 96, 0.2);
            border: 1px solid #27ae60;
            padding: 12px;
            border-radius: 6px;
            margin: 10px 0;
            color: #1e8449;
        }

        /* Calendar Grid */
        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 1px;
            background: #ddd;
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 20px;
        }

        .calendar-day {
            background: white;
            padding: 8px;
            min-height: 100px;
            cursor: pointer;
            position: relative;
            border: 1px solid #e9ecef;
            transition: all 0.2s ease;
        }

        .calendar-day:hover {
            background: #f8f9fa;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .calendar-day.today {
            background: #e3f2fd;
            border: 2px solid #2196f3;
        }

        .calendar-day-number {
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 0.9em;
            color: #2c3e50;
        }

        .calendar-event {
            font-size: 0.7em;
            padding: 2px 4px;
            margin: 1px 0;
            border-radius: 3px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .calendar-event:hover {
            transform: scale(1.02);
            z-index: 10;
        }

        .calendar-more-events {
            font-size: 0.7em;
            color: #7f8c8d;
            text-align: center;
            margin-top: 2px;
            cursor: pointer;
            padding: 2px;
            border-radius: 3px;
            background: rgba(52, 152, 219, 0.1);
        }

        /* Event List View */
        .event-list-item {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            cursor: pointer;
            transition: all 0.3s;
            border-left: 5px solid #3498db;
            margin-bottom: 15px;
        }

        .event-list-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }

        .event-list-item.past {
            opacity: 0.8;
        }

        .event-list-item.sheet-event {
            border-right: 3px solid #f39c12;
        }

        .event-status-badge {
            background: #f39c12;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.7em;
            margin-left: 8px;
        }

        .event-status-badge.manual-override {
            background: #9b59b6;
        }

        .event-status-badge.completed {
            background: #27ae60;
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
        }

        .modal-content {
            background: white;
            margin: 50px auto;
            padding: 30px;
            border-radius: 10px;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal h3 {
            margin-top: 0;
            color: #2c3e50;
        }

        /* Message Notifications */
        .message { 
            padding: 15px; 
            border-radius: 8px; 
            margin: 15px 0; 
            position: fixed; 
            top: 20px; 
            right: 20px; 
            z-index: 1001; 
            min-width: 300px; 
            box-shadow: 0 4px 12px rgba(0,0,0,0.15); 
            cursor: pointer; 
            transition: all 0.3s ease;
        }

        .message.success { 
            background: #d4edda; 
            color: #155724; 
            border: 1px solid #c3e6cb; 
        }

        .message.error { 
            background: #f8d7da; 
            color: #721c24; 
            border: 1px solid #f5c6cb; 
        }

        .message.info { 
            background: #d1ecf1; 
            color: #0c5460; 
            border: 1px solid #bee5eb; 
        }

        .message.warning { 
            background: #fff3cd; 
            color: #856404; 
            border: 1px solid #ffeaa7; 
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üç© Donuland Management System v2.1</h1>
            <div class="header-controls">
                <div class="sync-status">
                    <div class="status-indicator"></div>
                    <span id="syncStatusText">Inicializuji...</span>
                </div>
                <button class="btn btn-primary" onclick="loadData()">üîÑ Naƒç√≠st data</button>
            </div>
        </div>
        
        <div class="nav-tabs">
            <div class="nav-tab active" onclick="showTabFixed('prediction', event)">ü§ñ AI Predikce</div>
            <div class="nav-tab" onclick="showTabFixed('weekly', event)">üìã T√Ωdenn√≠ pl√°nov√°n√≠</div>
            <div class="nav-tab" onclick="showTabFixed('calendar', event)">üìÖ Kalend√°≈ô akc√≠</div>
            <div class="nav-tab" onclick="showTabFixed('analytics', event)">üìä Anal√Ωza & Trendy</div>
            <div class="nav-tab" onclick="showTabFixed('settings', event)">‚öôÔ∏è Nastaven√≠</div>
        </div>
        
        <div class="content-area">
          <!-- ƒå√ÅST 2: TAB CONTENT HTML -->
<!-- Vlo≈æte tuto ƒç√°st do <div class="content-area"> m√≠sto koment√°≈ôe "Content bude v dal≈°√≠ ƒç√°sti" -->

<!-- Tab: AI Predikce -->
<div id="prediction" class="tab-content active">
    <div class="form-section">
        <h3>üéØ Z√°kladn√≠ informace akce</h3>
        <div class="form-group">
            <label for="eventType">Typ akce</label>
            <select id="eventType" onchange="updatePrediction()">
                <option value="">Vyberte typ akce</option>
                <option value="food festival">Food festival</option>
                <option value="veletrh">Veletrh</option>
                <option value="koncert">Koncert/Hudebn√≠ festival</option>
                <option value="sportovni">Sportovn√≠ akce</option>
                <option value="kulturni">Kulturn√≠/Rodinn√° akce</option>
                <option value="rodinny festival">Rodinn√Ω festival</option>
                <option value="cokoladovy festival">ƒåokol√°dov√Ω festival</option>
                <option value="ostatni">Ostatn√≠</option>
            </select>
        </div>
        <div class="form-group">
            <label for="eventName">N√°zev akce</label>
            <input type="text" id="eventName" placeholder="nap≈ô. Burger Fest Praha" oninput="handleEventNameInput()" autocomplete="off">
            <div class="input-hint">Zaƒçnƒõte ps√°t pro zobrazen√≠ na≈°ept√°vaƒçe z historick√Ωch akc√≠</div>
        </div>
        <div class="form-row">
            <div class="form-group">
                <label for="eventLocation">Mƒõsto/Lokalita</label>
                <input type="text" id="eventLocation" placeholder="nap≈ô. Praha, Brno, Ostrava..." oninput="handleLocationInput()" autocomplete="off">
                <div class="input-hint">Automatick√© na≈°ept√°v√°n√≠ mƒõst s v√Ωpoƒçtem dopravy</div>
            </div>
            <div class="form-group">
                <label for="eventDate">Datum zaƒç√°tku akce</label>
                <input type="date" id="eventDate" onchange="loadWeather(); updatePrediction();">
            </div>
        </div>
        <div class="form-row">
            <div class="form-group">
                <label for="eventDuration">D√©lka akce (dny)</label>
                <select id="eventDuration" onchange="loadWeather(); updatePrediction();">
                    <option value="1">1 den</option>
                    <option value="2" selected>2 dny</option>
                    <option value="3">3 dny</option>
                    <option value="4">4 dny</option>
                    <option value="5">5 dn√≠</option>
                </select>
            </div>
            <div class="form-group">
                <label for="expectedVisitors">Oƒçek√°van√° n√°v≈°tƒõvnost</label>
                <input type="number" id="expectedVisitors" value="2000" min="0" onchange="updatePrediction()" oninput="validateVisitorCount()">
                <div class="input-hint">Z√°kladn√≠ √∫daj pro v√Ωpoƒçet predikce</div>
            </div>
        </div>
        <div class="form-group">
            <label for="eventEnvironment">Prost≈ôed√≠ akce</label>
            <select id="eventEnvironment" onchange="handleEnvironmentChange()">
                <option value="outdoor">Venkovn√≠ akce</option>
                <option value="indoor">Vnit≈ôn√≠ akce</option>
                <option value="mixed">Sm√≠≈°en√© (venku i uvnit≈ô)</option>
            </select>
            <div class="input-hint">Ovliv≈àuje d≈Øle≈æitost poƒças√≠ pro kvalitu donut≈Ø</div>
        </div>
        
        <div id="weatherSection" class="weather-section">
            <h4>üå§Ô∏è P≈ôedpovƒõƒè poƒças√≠ a kvalita donut≈Ø</h4>
            <div id="weatherDisplay" class="weather-display">
                <div class="weather-loading">üìç Vyberte mƒõsto, datum a d√©lku akce pro naƒçten√≠ poƒças√≠</div>
            </div>
            <div id="qualityWarning" class="inventory-alert" style="display: none;">
                ‚ö†Ô∏è <strong>Varov√°n√≠ kvality:</strong> Vysok√© teploty mohou zp≈Øsobit rozt√©k√°n√≠ ƒçokol√°dov√Ωch polev!
            </div>
        </div>
    </div>

    <div id="predictionSection" class="prediction-section">
        <h4>üìä Predikce prodeje a rentabilita</h4>
        
        <div class="business-model-selection">
            <h5>Model podnik√°n√≠:</h5>
            <div class="radio-group">
                <label>
                    <input type="radio" name="businessModel" value="owner" checked onchange="updatePrediction(); updateBusinessModelInfo();">
                    üè™ Majitel (vy + 2 brig√°dn√≠ci)
                </label>
                <label>
                    <input type="radio" name="businessModel" value="employee" onchange="updatePrediction(); updateBusinessModelInfo();">
                    üë∑ Zamƒõstnanec (vy + 1 brig√°dn√≠k)
                </label>
                <label>
                    <input type="radio" name="businessModel" value="franchisee" onchange="updatePrediction(); updateBusinessModelInfo();">
                    ü§ù Fran≈°√≠zant
                </label>
            </div>
            <div id="businessModelInfo" class="input-hint" style="margin-top: 10px; color: rgba(255,255,255,0.9);">
                Majitel: 2 brig√°dn√≠ci (150 Kƒç/h √ó 10h = 3000 Kƒç) + v≈°echny n√°klady
            </div>
        </div>
        
        <div class="financial-params">
            <div class="param-row">
                <label>N√°klady na donut (Kƒç):</label>
                <input type="number" id="donutCost" value="32" min="0" step="0.5" onchange="updatePrediction()">
            </div>
            <div class="param-row">
                <label>Prodejn√≠ cena (Kƒç):</label>
                <input type="number" id="sellingPrice" value="110" min="0" step="0.5" onchange="updatePrediction()">
            </div>
            <div class="param-row">
                <label>N√°klady na dopravu (Kƒç):</label>
                <input type="number" id="transportCost" value="500" min="0" step="50" onchange="updatePrediction()">
            </div>
            <div class="param-row">
                <label>Ostatn√≠ n√°klady (Kƒç):</label>
                <input type="number" id="otherCosts" value="200" min="0" step="50" onchange="updatePrediction()">
            </div>
            <div class="param-row">
                <label>Model n√°jmu:</label>
                <select id="rentalModel" onchange="updateRentalInputs()">
                    <option value="fixed">Fixn√≠ n√°jem</option>
                    <option value="percentage">Procentn√≠ n√°jem</option>
                    <option value="mixed">Sm√≠≈°en√Ω model</option>
                </select>
            </div>
            <div class="param-row" id="fixedRentalRow">
                <label>Fixn√≠ n√°jem (Kƒç):</label>
                <input type="number" id="fixedRental" value="5000" min="0" step="100" onchange="updatePrediction()">
            </div>
            <div class="param-row" id="percentageRentalRow" style="display: none;">
                <label>Procentn√≠ n√°jem (%):</label>
                <input type="number" id="percentageRental" value="15" min="0" max="50" step="0.5" onchange="updatePrediction()">
            </div>
        </div>

        <div id="predictionResults" class="prediction-results">
            <div class="prediction-loading">üìç Vypl≈àte typ akce a n√°v≈°tƒõvnost pro naƒçten√≠ predikce</div>
        </div>
    </div>
</div>

<!-- Tab: Weekly Planning -->
<div id="weekly" class="tab-content">
    <div class="weekly-planning-section">
        <h3>üìã T√Ωdenn√≠ pl√°nov√°n√≠ a objedn√°vky</h3>
        
        <div class="weekly-overview">
            <div class="week-metric">
                <div class="week-metric-value" id="weeklyEventsCount">-</div>
                <div class="week-metric-label">Pl√°novan√© akce</div>
            </div>
            <div class="week-metric">
                <div class="week-metric-value" id="weeklyPredictedSales">-</div>
                <div class="week-metric-label">Predikce prodeje (ks)</div>
            </div>
            <div class="week-metric">
                <div class="week-metric-value" id="currentInventory">-</div>
                <div class="week-metric-label">Souƒçasn√Ω sklad</div>
            </div>
            <div class="week-metric">
                <div class="week-metric-value" id="recommendedOrder">-</div>
                <div class="week-metric-label">Doporuƒçen√° objedn√°vka</div>
            </div>
            <div class="week-metric">
                <div class="week-metric-value" id="weeklyProfit">-</div>
                <div class="week-metric-label">Oƒçek√°van√Ω zisk (Kƒç)</div>
            </div>
        </div>
        
        <div class="param-row" style="background: rgba(255,255,255,0.15); padding: 15px; border-radius: 8px; margin-bottom: 20px;">
            <label>Souƒçasn√Ω sklad donut≈Ø (ks):</label>
            <input type="number" id="currentStock" value="0" min="0" onchange="calculateWeeklyPlan()">
        </div>
        
        <div class="param-row" style="background: rgba(255,255,255,0.15); padding: 15px; border-radius: 8px; margin-bottom: 20px;">
            <label>Bezpeƒçnostn√≠ rezerva (%):</label>
            <input type="number" id="safetyBuffer" value="15" min="0" max="50" onchange="calculateWeeklyPlan()">
        </div>
        
        <div id="weeklyInventoryStatus" class="inventory-ok" style="display: none;">
            ‚úÖ Skladov√© z√°soby jsou dostateƒçn√© pro pl√°novan√© akce
        </div>
        
        <div id="weeklyEventsList" style="background: rgba(255,255,255,0.15); padding: 15px; border-radius: 8px; margin-top: 20px;">
            <h5>üìÖ Akce v n√°sleduj√≠c√≠ch 7 dnech:</h5>
            <div id="weeklyEventsContent">≈Ω√°dn√© pl√°novan√© akce v n√°sleduj√≠c√≠ch 7 dnech</div>
        </div>
        
        <div style="display: flex; gap: 15px; margin-top: 20px; flex-wrap: wrap;">
            <button class="btn btn-success" onclick="exportWeeklyPlan()">üìä Export t√Ωdenn√≠ho pl√°nu</button>
            <button class="btn btn-primary" onclick="createOrderFromPlan()">üì¶ Vytvo≈ôit objedn√°vku</button>
            <button class="btn btn-warning" onclick="syncToSheet()">‚òÅÔ∏è Synchronizovat se Sheetem</button>
        </div>
    </div>
</div>
        </div>
        <!-- ƒå√ÅST 3: CALENDAR A ANALYTICS HTML -->
<!-- P≈ôidejte tuto ƒç√°st za ƒå√°st 2 (p≈ôed uzav√≠rac√≠ </div> content-area) -->

<!-- Tab: Calendar -->
<div id="calendar" class="tab-content">
    <div class="form-section">
        <h3>üìÖ Kalend√°≈ô akc√≠ a pl√°nov√°n√≠</h3>
        
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; flex-wrap: wrap; gap: 15px;">
            <div style="display: flex; align-items: center; gap: 15px;">
                <button class="btn btn-primary" onclick="previousMonth()">‚óÄ P≈ôedchoz√≠</button>
                <h4 id="monthYearDisplay" style="margin: 0; min-width: 200px; text-align: center;">Leden 2025</h4>
                <button class="btn btn-primary" onclick="nextMonth()">N√°sleduj√≠c√≠ ‚ñ∂</button>
            </div>
            <div style="display: flex; gap: 10px;">
                <button class="btn btn-success" onclick="toggleCalendarView()" id="viewToggleBtn">üìã Seznam akc√≠</button>
                <button class="btn btn-warning" onclick="exportCalendar()">üìä Export kalend√°≈ôe</button>
            </div>
        </div>
        
        <!-- Calendar Grid View -->
        <div id="calendarView">
            <div id="calendarGrid" class="calendar-grid">
                <!-- Calendar header -->
                <div style="background: #3498db; color: white; padding: 10px; text-align: center; font-weight: bold;">Po</div>
                <div style="background: #3498db; color: white; padding: 10px; text-align: center; font-weight: bold;">√öt</div>
                <div style="background: #3498db; color: white; padding: 10px; text-align: center; font-weight: bold;">St</div>
                <div style="background: #3498db; color: white; padding: 10px; text-align: center; font-weight: bold;">ƒåt</div>
                <div style="background: #3498db; color: white; padding: 10px; text-align: center; font-weight: bold;">P√°</div>
                <div style="background: #3498db; color: white; padding: 10px; text-align: center; font-weight: bold;">So</div>
                <div style="background: #3498db; color: white; padding: 10px; text-align: center; font-weight: bold;">Ne</div>
                <!-- Calendar days will be generated by JavaScript -->
            </div>
        </div>
        
        <!-- List View -->
        <div id="listView" style="display: none;">
            <div id="eventsList">
                <!-- Event list will be generated by JavaScript -->
            </div>
        </div>
        
        <!-- Calendar Legend -->
        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-top: 20px;">
            <h5 style="margin: 0 0 10px 0;">üìñ Legenda:</h5>
            <div style="display: flex; gap: 20px; flex-wrap: wrap; font-size: 0.9em;">
                <div>üìä <span style="background: #f39c12; color: white; padding: 2px 6px; border-radius: 3px;">ZE SHEETU</span> - Data ze Google Sheetu</div>
                <div>‚úèÔ∏è <span style="background: #9b59b6; color: white; padding: 2px 6px; border-radius: 3px;">UPRAVENO</span> - Ruƒçnƒõ upraven√° predikce</div>
                <div>üíö Zelen√© pozad√≠ - Ziskov√° akce</div>
                <div>‚ù§Ô∏è ƒåerven√© pozad√≠ - Ztr√°tov√° akce</div>
            </div>
        </div>
    </div>
</div>

<!-- Tab: Analytics -->
<div id="analytics" class="tab-content">
    <div id="analyticsContent">
        <div style="text-align: center; padding: 60px 20px; color: #7f8c8d;">
            <div style="font-size: 4em; margin-bottom: 20px; opacity: 0.3;">üìä</div>
            <h3 style="margin-bottom: 15px; color: #34495e;">Anal√Ωza prodejn√≠ch dat</h3>
            <p style="font-size: 1.1em; margin-bottom: 25px;">Zat√≠m nejsou dostupn√° ≈æ√°dn√° historick√° data pro anal√Ωzu.</p>
            <p style="margin-bottom: 30px;">Data se naƒçtou automaticky z Google Sheetu nebo m≈Ø≈æete vytvo≈ôit nov√© predikce.</p>
            <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
                <button class="btn btn-primary btn-large" onclick="loadData()">üîÑ Naƒç√≠st data ze Sheetu</button>
                <button class="btn btn-success" onclick="showTab('prediction', {target: document.querySelector('.nav-tab')})">ü§ñ Vytvo≈ôit predikci</button>
            </div>
        </div>
    </div>
</div>

<!-- Tab: Settings -->
<div id="settings" class="tab-content">
    <div class="form-section">
        <h3>‚öôÔ∏è Nastaven√≠ syst√©mu</h3>
        
        <div style="display: grid; gap: 20px;">
            <!-- Cenov√© nastaven√≠ -->
            <div style="background: white; padding: 20px; border-radius: 8px; border-left: 4px solid #27ae60;">
                <h4 style="color: #27ae60; margin-bottom: 15px;">üí∞ Cenov√© nastaven√≠</h4>
                <div class="form-row">
                    <div class="form-group">
                        <label for="defaultDonutPrice">V√Ωchoz√≠ prodejn√≠ cena donutu (Kƒç)</label>
                        <input type="number" id="defaultDonutPrice" value="110" min="0" step="0.5">
                    </div>
                    <div class="form-group">
                        <label for="defaultDonutCost">N√°klady na v√Ωrobu donutu (Kƒç)</label>
                        <input type="number" id="defaultDonutCost" value="32" min="0" step="0.5">
                    </div>
                </div>
                <div class="form-row">
                    <div class="form-group">
                        <label for="franchiseDonutPrice">Prodejn√≠ cena fran≈°√≠zant≈Øm (Kƒç)</label>
                        <input type="number" id="franchiseDonutPrice" value="52" min="0" step="0.5">
                    </div>
                    <div class="form-group">
                        <label for="defaultTransportRate">N√°klady na dopravu (Kƒç/km)</label>
                        <input type="number" id="defaultTransportRate" value="10" min="0" step="0.5">
                    </div>
                </div>
            </div>
            
            <!-- Provozn√≠ nastaven√≠ -->
            <div style="background: white; padding: 20px; border-radius: 8px; border-left: 4px solid #3498db;">
                <h4 style="color: #3498db; margin-bottom: 15px;">üîß Provozn√≠ nastaven√≠</h4>
                <div class="form-row">
                    <div class="form-group">
                        <label for="qualityTempThreshold">Teplotn√≠ pr√°h pro kvalitu (¬∞C)</label>
                        <input type="number" id="qualityTempThreshold" value="28" min="15" max="40">
                        <div class="input-hint">Teplota, p≈ôi kter√© se zobrazuje varov√°n√≠ kvality</div>
                    </div>
                    <div class="form-group">
                        <label for="defaultEventDuration">V√Ωchoz√≠ d√©lka akce (dny)</label>
                        <select id="defaultEventDuration">
                            <option value="1">1 den</option>
                            <option value="2" selected>2 dny</option>
                            <option value="3">3 dny</option>
                        </select>
                    </div>
                </div>
            </div>
            
            <!-- API nastaven√≠ -->
            <div style="background: white; padding: 20px; border-radius: 8px; border-left: 4px solid #9b59b6;">
                <h4 style="color: #9b59b6; margin-bottom: 15px;">üîå API a integrace</h4>
                <div class="form-group">
                    <label>Status slu≈æeb:</label>
                    <div style="display: grid; gap: 8px; margin-top: 8px;">
                        <div id="weatherApiStatus">üå§Ô∏è Weather API: <span style="color: #27ae60;">‚úÖ Aktivn√≠</span></div>
                        <div id="mapsApiStatus">üó∫Ô∏è Google Maps API: <span style="color: #27ae60;">‚úÖ Aktivn√≠</span></div>
                        <div id="sheetApiStatus">üìä Google Sheets: <span style="color: #27ae60;">‚úÖ P≈ôipojeno</span></div>
                    </div>
                </div>
                <div class="form-group">
                    <button class="btn btn-primary" onclick="testAllConnections()">üîç Otestovat v≈°echna spojen√≠</button>
                </div>
            </div>
            
            <!-- Z√°lohy a √∫dr≈æba -->
            <div style="background: white; padding: 20px; border-radius: 8px; border-left: 4px solid #e74c3c;">
                <h4 style="color: #e74c3c; margin-bottom: 15px;">üîí Z√°lohy a √∫dr≈æba</h4>
                <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 15px;">
                    <button class="btn btn-success" onclick="createManualBackup()">üíæ Vytvo≈ôit z√°lohu</button>
                    <button class="btn btn-warning" onclick="restoreFromBackup()">üìÅ Obnovit ze z√°lohy</button>
                    <button class="btn btn-primary" onclick="exportSettings()">üìã Export nastaven√≠</button>
                </div>
                <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 15px;">
                    <button class="btn btn-primary" onclick="showSystemDiagnostics()">üîç Syst√©mov√° diagnostika</button>
                    <button class="btn btn-danger" onclick="clearAllData()">üóëÔ∏è Vymazat v≈°echna data</button>
                </div>
                <div id="lastBackupInfo" style="font-size: 0.9em; color: #7f8c8d; margin-top: 10px;">
                    üíæ Kontrola posledn√≠ch z√°loh...
                </div>
            </div>
            
            <!-- Kalkulace a p≈ôehledy -->
            <div style="background: white; padding: 20px; border-radius: 8px; border-left: 4px solid #f39c12;">
                <h4 style="color: #f39c12; margin-bottom: 15px;">üìä Souƒçasn√© kalkulace</h4>
                <div id="currentCalculations" style="display: grid; gap: 10px; font-size: 0.95em;">
                    <div>üç© <strong>Mar≈æe na donut (bƒõ≈æn√Ω prodej):</strong> <span id="regularMargin">78 Kƒç</span></div>
                    <div>ü§ù <strong>Mar≈æe na donut (fran≈°√≠za):</strong> <span id="franchiseMargin">20 Kƒç</span></div>
                    <div>üíº <strong>Fran≈°√≠zantova mar≈æe:</strong> <span id="franchiseeMargin">58 Kƒç</span></div>
                    <div>üöö <strong>Doprava Praha-Brno:</strong> <span id="transportExample">~4 100 Kƒç</span></div>
                </div>
            </div>
        </div>
        
        <div style="display: flex; gap: 15px; margin-top: 30px; flex-wrap: wrap; justify-content: center;">
            <button class="btn btn-success btn-large" onclick="saveSettings()">üíæ Ulo≈æit nastaven√≠</button>
            <button class="btn btn-warning" onclick="resetToDefaults()">üîÑ Obnovit v√Ωchoz√≠</button>
            <button class="btn btn-primary" onclick="loadSettings()">üìÅ Naƒç√≠st nastaven√≠</button>
        </div>
    </div>
</div>

<!-- Modal pro detaily akc√≠ -->
<div id="eventModal" class="modal" onclick="if(event.target === this) closeEventModal()">
    <div class="modal-content">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <div style="flex: 1;"></div>
            <div style="display: flex; gap: 10px;">
                <button class="btn btn-warning" onclick="editEvent()" id="editEventBtn" style="display: none;">‚úèÔ∏è Upravit</button>
                <button class="btn btn-danger" onclick="deleteEvent()" id="deleteEventBtn">üóëÔ∏è Smazat</button>
                <button class="btn btn-primary" onclick="closeEventModal()">‚úñÔ∏è Zav≈ô√≠t</button>
            </div>
        </div>
        <div id="eventModalContent">
            <!-- Event details will be loaded here -->
        </div>
    </div>
</div>
    </div>
    // ƒå√ÅST 4: Z√ÅKLADN√ç JAVASCRIPT SETUP
// Vlo≈æte tuto ƒç√°st do <script> tagu p≈ôed uzav√≠rac√≠ </body>

// =============================================================================
// GLOBAL VARIABLES AND CONSTANTS
// =============================================================================

let allSheetData = [];
let historicalData = [];
let plannedEvents = [];
let localSavedEvents = [];
let lastPrediction = null;
let currentDate = new Date();
let calendarView = 'month';
let selectedEventId = null;
let currentWeatherData = null;
let autocompleteData = {
    eventNames: [],
    locations: []
};

// API keys and constants
const WEATHER_API_KEY = 'c2fb0e86623880dc86162892b0fd9c95';
const GOOGLE_MAPS_API_KEY = 'AIzaSyBTTA_MKa6FrxKpkcd7c5-d3FnC6FBLVTc';
const SHEET_ID = '1LclCz9hb0hlb1D92OyVqk6Cbam7PRK6KgAzGgiGs6iE';
const PRAGUE_COORDS = { lat: 50.0755, lon: 14.4378 };

const eventColors = [
    '#3498db', '#9b59b6', '#e74c3c', '#f39c12',
    '#8e44ad', '#e91e63', '#795548', '#607d8b',
    '#27ae60', '#e67e22', '#34495e', '#16a085'
];

// Business model configurations
const businessModels = {
    owner: {
        laborCost: 3000, // 2 brig√°dn√≠ci √ó 150 Kƒç/h √ó 10h
        description: 'Majitel: 2 brig√°dn√≠ci (150 Kƒç/h √ó 10h = 3000 Kƒç) + v≈°echny n√°klady',
        donutCost: 32,
        hasRevenueshare: false
    },
    employee: {
        laborCost: 1500, // 1 brig√°dn√≠k √ó 150 Kƒç/h √ó 10h
        ownWage: 1500, // Vlastn√≠ mzda √ó 150 Kƒç/h √ó 10h
        revenueShare: 0.05, // 5% z obratu
        description: 'Zamƒõstnanec: vlastn√≠ mzda (1500 Kƒç) + 1 brig√°dn√≠k (1500 Kƒç) + 5% z obratu',
        donutCost: 32,
        hasRevenueshare: true
    },
    franchisee: {
        donutCost: 52, // N√°kupn√≠ cena od v√°s
        yourProfit: 20, // V√°≈° zisk na donut (52 - 32)
        description: 'Fran≈°√≠zant: nakupuje donuty za 52 Kƒç, v√°≈° zisk 20 Kƒç/donut',
        hasRevenueshare: false,
        isYourProfitCalculation: true
    }
};

// Google Maps variables
let googleMapsLoaded = false;
let placesService = null;
let autocompleteService = null;

// =============================================================================
// CORE UI FUNCTIONS
// =============================================================================
// === OPRAVA NAVIGACE MEZI TABY ===
function showTabFixed(tabName, event) {
    console.log('üîÑ Switching to tab:', tabName);
    
    // Skr√Ωt v≈°echny taby
    document.querySelectorAll('.tab-content').forEach(tab => {
        tab.classList.remove('active');
        tab.style.display = 'none';
    });
    
    // Odstranit aktivn√≠ t≈ô√≠du ze v≈°ech navigation tab≈Ø
    document.querySelectorAll('.nav-tab').forEach(tab => {
        tab.classList.remove('active');
    });
    
    // Zobrazit vybran√Ω tab
    const targetTab = document.getElementById(tabName);
    if (targetTab) {
        targetTab.classList.add('active');
        targetTab.style.display = 'block';
    } else {
        console.error('Tab not found:', tabName);
        return;
    }
    
    // Oznaƒçit aktivn√≠ navigation tab
    if (event && event.target) {
        event.target.classList.add('active');
    }
    
    // Inicializovat specifick√Ω obsah tabu
    switch(tabName) {
        case 'calendar':
            setTimeout(() => initializeCalendar(), 100);
            break;
        case 'analytics':
            setTimeout(() => loadAnalytics(), 100);
            break;
        case 'weekly':
            setTimeout(() => calculateWeeklyPlan(), 100);
            break;
        case 'settings':
            setTimeout(() => loadSettings(), 100);
            break;
    }
}

// P≈ôeps√°n√≠ p≈Øvodn√≠ showTab funkce
window.showTab = showTabFixed;
function showTab(tabName, event) {
    console.log('üîÑ Switching to tab:', tabName);
    
    // Hide all tabs
    document.querySelectorAll('.tab-content').forEach(tab => 
        tab.classList.remove('active')
    );
    document.querySelectorAll('.nav-tab').forEach(tab => 
        tab.classList.remove('active')
    );
    
    // Show selected tab
    const targetTab = document.getElementById(tabName);
    if (targetTab) {
        targetTab.classList.add('active');
    }
    
    if (event && event.target) {
        event.target.classList.add('active');
    }
    
    // Initialize specific tab content
    switch(tabName) {
        case 'calendar':
            initializeCalendar();
            break;
        case 'analytics':
            loadAnalytics();
            break;
        case 'weekly':
            calculateWeeklyPlan();
            break;
        case 'settings':
            loadSettings();
            break;
    }
}

function showMessage(text, type = 'info') {
    // Remove existing messages
    document.querySelectorAll('.message').forEach(msg => msg.remove());
    
    const message = document.createElement('div');
    message.className = `message ${type}`;
    message.textContent = text;
    document.body.appendChild(message);
    
    // Auto-remove after 4 seconds
    setTimeout(() => { 
        if (message.parentNode) message.remove(); 
    }, 4000);
    
    // Click to remove
    message.onclick = () => message.remove();
    
    console.log(`üì¢ Message (${type}):`, text);
}

function updateSyncStatus(status, message) {
    const indicator = document.querySelector('.status-indicator');
    const text = document.getElementById('syncStatusText');
    
    if (!indicator || !text) return;
    
    switch(status) {
        case 'success':
            indicator.style.background = '#27ae60';
            indicator.style.animation = 'none';
            text.textContent = 'P≈ôipojeno';
            break;
        case 'error':
            indicator.style.background = '#e74c3c';
            indicator.style.animation = 'none';
            text.textContent = 'Chyba';
            break;
        case 'loading':
            indicator.style.background = '#f39c12';
            indicator.style.animation = 'pulse 2s infinite';
            text.textContent = 'Naƒç√≠t√°m...';
            break;
    }
    
    if (message) {
        indicator.title = message;
        text.title = message;
    }
}

// =============================================================================
// UTILITY FUNCTIONS
// =============================================================================

// === OPRAVA MODELU PODNIK√ÅN√ç ===
function updateBusinessModelInfo() {
    const selectedModel = document.querySelector('input[name="businessModel"]:checked')?.value || 'owner';
    const infoElement = document.getElementById('businessModelInfo');
    
    // Definice model≈Ø s pln√Ωmi n√°zvy
    const businessModels = {
        owner: {
            laborCost: 3000,
            description: 'üè™ Majitel: 2 brig√°dn√≠ci (150 Kƒç/h √ó 10h = 3000 Kƒç) + v≈°echny n√°klady',
            donutCost: 32,
            hasRevenueshare: false,
            displayName: 'üè™ Majitel (vy + 2 brig√°dn√≠ci)'
        },
        employee: {
            laborCost: 1500,
            ownWage: 1500,
            revenueShare: 0.05,
            description: 'üë∑ Zamƒõstnanec: vlastn√≠ mzda (1500 Kƒç) + 1 brig√°dn√≠k (1500 Kƒç) + 5% z obratu',
            donutCost: 32,
            hasRevenueshare: true,
            displayName: 'üë∑ Zamƒõstnanec (vy + 1 brig√°dn√≠k)'
        },
        franchisee: {
            donutCost: 52,
            yourProfit: 20,
            description: 'ü§ù Fran≈°√≠zant: nakupuje donuty za 52 Kƒç, v√°≈° zisk 20 Kƒç/donut',
            hasRevenueshare: false,
            isYourProfitCalculation: true,
            displayName: 'ü§ù Fran≈°√≠zant'
        }
    };
    
    const selectedModelData = businessModels[selectedModel];
    
    // Aktualizovat popis
    if (infoElement && selectedModelData) {
        infoElement.textContent = selectedModelData.description;
        infoElement.style.color = 'rgba(255,255,255,0.9)';
        infoElement.style.marginTop = '10px';
    }
    
    // Aktualizovat n√°klady na donut
    const donutCostInput = document.getElementById('donutCost');
    if (donutCostInput && selectedModelData) {
        donutCostInput.value = selectedModelData.donutCost;
    }
    
    // Zmƒõnit label podle modelu
    const donutCostLabel = document.querySelector('label[for="donutCost"]') || 
                          document.querySelector('#donutCost').parentElement.querySelector('label');
    
    if (donutCostLabel) {
        if (selectedModel === 'franchisee') {
            donutCostLabel.textContent = 'Prodejn√≠ cena fran≈°√≠zantovi (Kƒç):';
        } else {
            donutCostLabel.textContent = 'N√°klady na donut (Kƒç):';
        }
    }
    
    // Aktualizovat zobrazovan√© n√°zvy v radio buttonech
    updateBusinessModelLabels();
    
    console.log(`‚úÖ Business model updated to: ${selectedModel} - ${selectedModelData.displayName}`);
}

// Nov√° funkce pro aktualizaci label≈Ø
function updateBusinessModelLabels() {
    const labels = document.querySelectorAll('input[name="businessModel"] + label, label:has(input[name="businessModel"])');
    
    // Pokud nejsou labely nalezeny standardnƒõ, hled√°me jinak
    const radioInputs = document.querySelectorAll('input[name="businessModel"]');
    
    radioInputs.forEach(input => {
        let label = input.nextElementSibling;
        if (!label || label.tagName !== 'LABEL') {
            label = input.parentElement;
        }
        
        if (label) {
            switch(input.value) {
                case 'owner':
                    label.innerHTML = `
                        <input type="radio" name="businessModel" value="owner" ${input.checked ? 'checked' : ''}>
                        üè™ Majitel (vy + 2 brig√°dn√≠ci)
                    `;
                    break;
                case 'employee':
                    label.innerHTML = `
                        <input type="radio" name="businessModel" value="employee" ${input.checked ? 'checked' : ''}>
                        üë∑ Zamƒõstnanec (vy + 1 brig√°dn√≠k)
                    `;
                    break;
                case 'franchisee':
                    label.innerHTML = `
                        <input type="radio" name="businessModel" value="franchisee" ${input.checked ? 'checked' : ''}>
                        ü§ù Fran≈°√≠zant
                    `;
                    break;
            }
            
            // Znovu p≈ôidat event listener
            const newInput = label.querySelector('input');
            if (newInput) {
                newInput.addEventListener('change', function() {
                    updateBusinessModelInfo();
                    updatePrediction();
                });
            }
        }
    });
}

// Zajistit, ≈æe se funkce spust√≠ p≈ôi naƒçten√≠
document.addEventListener('DOMContentLoaded', function() {
    // Mal√© zpo≈ædƒõn√≠ pro jistotu, ≈æe HTML je plnƒõ naƒçten
    setTimeout(() => {
        updateBusinessModelInfo();
        updateBusinessModelLabels();
        
        // P≈ôidat event listenery pro business model radio buttony
        document.querySelectorAll('input[name="businessModel"]').forEach(radio => {
            radio.addEventListener('change', function() {
                updateBusinessModelInfo();
                updatePrediction();
            });
        });
    }, 500);
});

function handleEnvironmentChange() {
    const environment = document.getElementById('eventEnvironment').value;
    const weatherSection = document.getElementById('weatherSection');
    const qualityWarning = document.getElementById('qualityWarning');
    
    if (environment === 'indoor') {
        if (weatherSection) weatherSection.style.opacity = '0.7';
        if (qualityWarning) qualityWarning.style.display = 'none';
        showMessage('Vnit≈ôn√≠ akce - sn√≠≈æen√Ω vliv poƒças√≠ na kvalitu donut≈Ø', 'info');
    } else {
        if (weatherSection) weatherSection.style.opacity = '1';
        if (currentWeatherData && currentWeatherData.qualityRisk && qualityWarning) {
            qualityWarning.style.display = 'block';
        }
    }
    
    updatePrediction();
}

function validateVisitorCount() {
    const input = document.getElementById('expectedVisitors');
    const value = parseInt(input.value);
    const formGroup = input.parentElement;
    
    // Remove existing classes
    formGroup.classList.remove('has-error', 'has-success');
    
    if (value < 100) {
        formGroup.classList.add('has-error');
        showMessage('Pozor: Velmi n√≠zk√° n√°v≈°tƒõvnost m≈Ø≈æe sn√≠≈æit p≈ôesnost predikce', 'warning');
    } else if (value > 50000) {
        formGroup.classList.add('has-error');
        showMessage('Pozor: Velmi vysok√° n√°v≈°tƒõvnost - zkontrolujte zad√°n√≠', 'warning');
    } else {
        formGroup.classList.add('has-success');
    }
}

// === OPRAVA SYST√âMU N√ÅJMU ===
function updateRentalInputs() {
    const model = document.getElementById('rentalModel')?.value || 'fixed';
    const fixedRow = document.getElementById('fixedRentalRow');
    const percentageRow = document.getElementById('percentageRentalRow');
    
    if (!fixedRow || !percentageRow) {
        console.error('Rental input rows not found');
        return;
    }
    
    // Skr√Ωt v≈°echny ≈ô√°dky nejd≈ô√≠ve
    fixedRow.style.display = 'none';
    percentageRow.style.display = 'none';
    
    switch(model) {
        case 'fixed':
            // Pouze fixn√≠ n√°jem
            fixedRow.style.display = 'flex';
            updateRentalLabel('Fixn√≠ n√°jem (Kƒç):', 'Cel√Ω n√°jem je fixn√≠ ƒç√°stka');
            break;
            
        case 'percentage':
            // Pouze procentn√≠ n√°jem
            percentageRow.style.display = 'flex';
            updateRentalLabel('', 'N√°jem jako % z obratu');
            break;
            
        case 'mixed':
            // Fixn√≠ + procentn√≠
            fixedRow.style.display = 'flex';
            percentageRow.style.display = 'flex';
            updateRentalLabel('Fixn√≠ ƒç√°st n√°jmu (Kƒç):', 'Fixn√≠ ƒç√°st + % z obratu');
            break;
            
        default:
            fixedRow.style.display = 'flex';
            break;
    }
    
    // P≈ôepoƒç√≠tat predikci po zmƒõnƒõ
    updatePrediction();
}

function updateRentalLabel(fixedLabel, description) {
    // Aktualizovat label pro fixn√≠ n√°jem
    if (fixedLabel) {
        const fixedLabelElement = document.querySelector('#fixedRentalRow label');
        if (fixedLabelElement) {
            fixedLabelElement.textContent = fixedLabel;
        }
    }
    
    // P≈ôidat nebo aktualizovat popis
    let descElement = document.getElementById('rentalDescription');
    if (!descElement) {
        descElement = document.createElement('div');
        descElement.id = 'rentalDescription';
        descElement.style.cssText = `
            font-size: 0.85em; 
            color: rgba(255,255,255,0.8); 
            margin-top: 5px; 
            font-style: italic;
        `;
        
        const rentalModelSelect = document.getElementById('rentalModel');
        if (rentalModelSelect && rentalModelSelect.parentElement) {
            rentalModelSelect.parentElement.appendChild(descElement);
        }
    }
    
    if (descElement) {
        descElement.textContent = description;
    }
}

// Vylep≈°en√° funkce pro v√Ωpoƒçet n√°jmu
function calculateRentalCost(revenue) {
    const rentalModel = document.getElementById('rentalModel')?.value || 'fixed';
    let rentalCost = 0;
    
    switch(rentalModel) {
        case 'fixed':
            rentalCost = parseFloat(document.getElementById('fixedRental')?.value) || 5000;
            break;
            
        case 'percentage':
            const percentage = parseFloat(document.getElementById('percentageRental')?.value) || 15;
            rentalCost = revenue * (percentage / 100);
            break;
            
        case 'mixed':
            const fixed = parseFloat(document.getElementById('fixedRental')?.value) || 2500;
            const percent = parseFloat(document.getElementById('percentageRental')?.value) || 10;
            rentalCost = fixed + (revenue * (percent / 100));
            break;
            
        default:
            rentalCost = 5000;
            break;
    }
    
    return Math.max(0, rentalCost);
}

// Aktualizovat event listener pro rental model
document.addEventListener('DOMContentLoaded', function() {
    setTimeout(() => {
        const rentalModelSelect = document.getElementById('rentalModel');
        if (rentalModelSelect) {
            rentalModelSelect.addEventListener('change', updateRentalInputs);
            
            // Inicializovat na zaƒç√°tku
            updateRentalInputs();
        }
        
        // Event listenery pro rental inputy
        ['fixedRental', 'percentageRental'].forEach(id => {
            const element = document.getElementById(id);
            if (element) {
                element.addEventListener('change', updatePrediction);
                element.addEventListener('input', debounce(updatePrediction, 500));
            }
        });
    }, 600);
});

function generateEventId(name, date, location) {
    const str = `${name}-${date}-${location}`.toLowerCase()
        .replace(/\s+/g, '-')
        .replace(/[^\w-]/g, '');
    return btoa(str).replace(/[^a-zA-Z0-9]/g, '').substring(0, 16);
}

function parseIntSafe(value) {
    if (!value || value === '') return 0;
    const num = value.toString().replace(/[^\d-]/g, '');
    const parsed = parseInt(num);
    return isNaN(parsed) ? 0 : Math.max(0, parsed);
}

function parseFloatSafe(value) {
    if (!value || value === '') return 0;
    const num = value.toString().replace(/[^\d.,-]/g, '').replace(',', '.');
    const parsed = parseFloat(num);
    return isNaN(parsed) ? 0 : Math.max(0, parsed);
}

function adjustColorOpacity(color, opacity) {
    // Simple opacity adjustment for hex colors
    if (color.startsWith('#')) {
        return color + Math.floor(opacity * 255).toString(16).padStart(2, '0');
    }
    return color;
}

function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

// =============================================================================
// PLACEHOLDER FUNCTIONS (budou implementov√°ny v dal≈°√≠ch ƒç√°stech)
// =============================================================================

// Data loading functions
function loadData() {
    console.log('loadData() - bude implementov√°no v ƒç√°sti 5');
    updateSyncStatus('loading', 'Naƒç√≠t√°m data...');
    // Implementace bude v ƒç√°sti 5
}

// Prediction functions
function updatePrediction() {
    console.log('updatePrediction() - bude implementov√°no v ƒç√°sti 6');
    // Implementace bude v ƒç√°sti 6
}

// Weather functions
function loadWeather() {
    console.log('loadWeather() - bude implementov√°no v ƒç√°sti 7');
    // Implementace bude v ƒç√°sti 7
}

// Calendar functions
function initializeCalendar() {
    console.log('initializeCalendar() - bude implementov√°no v ƒç√°sti 8');
    // Implementace bude v ƒç√°sti 8
}

function previousMonth() {
    currentDate.setMonth(currentDate.getMonth() - 1);
    if (typeof renderCalendar === 'function') renderCalendar();
    updateMonthYearDisplay();
}

function nextMonth() {
    currentDate.setMonth(currentDate.getMonth() + 1);
    if (typeof renderCalendar === 'function') renderCalendar();
    updateMonthYearDisplay();
}

function updateMonthYearDisplay() {
    const display = document.getElementById('monthYearDisplay');
    if (display) {
        const months = [
            'Leden', '√önor', 'B≈ôezen', 'Duben', 'Kvƒõten', 'ƒåerven',
            'ƒåervenec', 'Srpen', 'Z√°≈ô√≠', '≈ò√≠jen', 'Listopad', 'Prosinec'
        ];
        display.textContent = `${months[currentDate.getMonth()]} ${currentDate.getFullYear()}`;
    }
}

function toggleCalendarView() {
    // Implementace bude v ƒç√°sti 8
    console.log('toggleCalendarView() - bude implementov√°no v ƒç√°sti 8');
}

// Analytics functions
function loadAnalytics() {
    console.log('loadAnalytics() - bude implementov√°no v ƒç√°sti 9');
    // Implementace bude v ƒç√°sti 9
}

// Weekly planning functions
function calculateWeeklyPlan() {
    console.log('calculateWeeklyPlan() - bude implementov√°no v ƒç√°sti 10');
    // Implementace bude v ƒç√°sti 10
}

// Settings functions
function loadSettings() {
    console.log('loadSettings() - bude implementov√°no v ƒç√°sti 11');
    // Implementace bude v ƒç√°sti 11
}

function saveSettings() {
    console.log('saveSettings() - bude implementov√°no v ƒç√°sti 11');
    // Implementace bude v ƒç√°sti 11
}

// Autocomplete functions
function handleEventNameInput() {
    console.log('handleEventNameInput() - bude implementov√°no v ƒç√°sti 12');
    // Implementace bude v ƒç√°sti 12
}

function handleLocationInput() {
    console.log('handleLocationInput() - bude implementov√°no v ƒç√°sti 12');
    // Implementace bude v ƒç√°sti 12
}

// Export functions
function exportCalendar() {
    console.log('exportCalendar() - bude implementov√°no v ƒç√°sti 13');
    // Implementace bude v ƒç√°sti 13
}

function exportWeeklyPlan() {
    console.log('exportWeeklyPlan() - bude implementov√°no v ƒç√°sti 13');
    // Implementace bude v ƒç√°sti 13
}

// Modal and event functions
function closeEventModal() {
    const modal = document.getElementById('eventModal');
    if (modal) {
        modal.style.display = 'none';
        document.body.style.overflow = 'auto';
    }
    selectedEventId = null;
}

function editEvent() {
    console.log('editEvent() - bude implementov√°no v ƒç√°sti 14');
    // Implementace bude v ƒç√°sti 14
}

function deleteEvent() {
    console.log('deleteEvent() - bude implementov√°no v ƒç√°sti 14');
    // Implementace bude v ƒç√°sti 14
}

// Backup and maintenance functions
function createManualBackup() {
    console.log('createManualBackup() - bude implementov√°no v ƒç√°sti 15');
    // Implementace bude v ƒç√°sti 15
}

function restoreFromBackup() {
    console.log('restoreFromBackup() - bude implementov√°no v ƒç√°sti 15');
    // Implementace bude v ƒç√°sti 15
}

function showSystemDiagnostics() {
    console.log('showSystemDiagnostics() - bude implementov√°no v ƒç√°sti 15');
    // Implementace bude v ƒç√°sti 15
}

function clearAllData() {
    console.log('clearAllData() - bude implementov√°no v ƒç√°sti 15');
    // Implementace bude v ƒç√°sti 15
}

// =============================================================================
// INITIALIZATION
// =============================================================================

document.addEventListener('DOMContentLoaded', function() {
    console.log('üöÄ Initializing Donuland Management System v2.1...');
    
    try {
        // Set default date to tomorrow
        const tomorrow = new Date();
        tomorrow.setDate(tomorrow.getDate() + 1);
        const dateInput = document.getElementById('eventDate');
        if (dateInput) {
            dateInput.value = tomorrow.toISOString().split('T')[0];
        }
        
        // Initialize basic components
        updateMonthYearDisplay();
        updateBusinessModelInfo();
        
        console.log('‚úÖ Basic initialization complete');
        showMessage('Aplikace byla √∫spƒõ≈°nƒõ inicializov√°na', 'success');
        
    } catch (error) {
        console.error('‚ùå Initialization error:', error);
        showMessage('Chyba p≈ôi inicializaci aplikace', 'error');
    }
});

// Global error handler
window.addEventListener('error', (e) => {
    console.error('Global error:', e.error);
    showMessage('Do≈°lo k neoƒçek√°van√© chybƒõ. Zkuste obnovit str√°nku.', 'error');
});

console.log('üìù ƒå√°st 4 naƒçtena - Z√°kladn√≠ JavaScript setup');
    // ƒå√ÅST 5: DATA LOADING A GOOGLE SHEETS INTEGRACE
// P≈ôidejte tuto ƒç√°st za ƒå√°st 4 v <script> tagu

// =============================================================================
// DATA LOADING AND MANAGEMENT
// =============================================================================

async function loadData() {
    try {
        updateSyncStatus('loading', 'Naƒç√≠t√°m data...');
        await loadHistoricalData();
        loadLocalSavedEvents();
        updateAutocompleteData();
        updateSyncStatus('success', `Naƒçteno: ${historicalData.length} historick√Ωch, ${plannedEvents.length} pl√°novan√Ωch akc√≠`);
        showMessage('Data byla √∫spƒõ≈°nƒõ naƒçtena', 'success');
    } catch (error) {
        updateSyncStatus('error', 'Chyba p≈ôi naƒç√≠t√°n√≠ dat');
        showMessage('Chyba p≈ôi naƒç√≠t√°n√≠ dat ze Sheetu: ' + error.message, 'error');
        console.error('Load data error:', error);
        
        // Try to load fallback data
        loadFallbackData();
    }
}

// === OPRAVA NAƒå√çT√ÅN√ç DAT ZE SHEETU ===
async function loadHistoricalData() {
    try {
        console.log('üîÑ Loading data from Google Sheet...');
        updateSyncStatus('loading', 'Naƒç√≠t√°m data ze Sheetu...');
        
        // Pou≈æ√≠t CORS proxy pro p≈ô√≠stup k Google Sheets
        const csvUrl = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/export?format=csv&gid=0`;
        
        console.log('üìä Fetching CSV from:', csvUrl);
        
        const response = await fetch(csvUrl, {
            method: 'GET',
            headers: {
                'Accept': 'text/csv,text/plain,*/*',
                'Cache-Control': 'no-cache'
            }
        });
        
        if (!response.ok) {
            throw new Error(`HTTP chyba: ${response.status} - ${response.statusText}`);
        }
        
        const csvText = await response.text();
        console.log('üìù CSV response length:', csvText.length);
        
        if (!csvText || csvText.trim().length < 10) {
            throw new Error('Pr√°zdn√° nebo neplatn√° CSV data');
        }
        
        // Kontrola, zda nejde o HTML chybovou str√°nku
        if (csvText.includes('<!DOCTYPE html>') || csvText.includes('<html>')) {
            throw new Error('Google Sheet nen√≠ ve≈ôejnƒõ dostupn√Ω nebo neexistuje');
        }
        
        // Kontrola, zda obsahuje data
        if (csvText.includes('Sorry, unable to open the file') || 
            csvText.includes('File not found')) {
            throw new Error('Google Sheet nebyl nalezen - zkontrolujte SHEET_ID');
        }
        
        console.log('üìä Parsing CSV data...');
        console.log('First 200 chars:', csvText.substring(0, 200));
        
        allSheetData = parseCSVDataImproved(csvText);
        console.log(`üìã Parsed ${allSheetData.length} total events from sheet`);
        
        // Rozdƒõlen√≠ historick√Ωch a pl√°novan√Ωch akc√≠
        const currentDate = new Date();
        currentDate.setHours(0, 0, 0, 0); // Nastavit na zaƒç√°tek dne
        
        historicalData = [];
        plannedEvents = [];
        
        allSheetData.forEach(event => {
            try {
                const eventDate = new Date(event.date || event.eventDate);
                eventDate.setHours(0, 0, 0, 0);
                
                if (eventDate < currentDate) {
                    // Historick√° akce - mus√≠ m√≠t skuteƒçn√Ω prodej
                    if (event.actualSales && event.actualSales > 0) {
                        historicalData.push(event);
                    }
                } else {
                    // Budouc√≠ akce - mus√≠ b√Ωt potvrzen√°
                    if (event.confirmed === 'ANO' || event.confirmed === 'ano' || 
                        event.confirmed === 'Yes' || event.confirmed === 'yes' ||
                        event.confirmed === '1' || event.confirmed === true) {
                        plannedEvents.push(event);
                    }
                }
            } catch (parseError) {
                console.warn('Error processing event:', event, parseError);
            }
        });
        
        console.log('‚úÖ Data categorization complete:', {
            total: allSheetData.length,
            historical: historicalData.length,
            planned: plannedEvents.length
        });
        
        // Ulo≈æit ƒçasov√© raz√≠tko posledn√≠ho naƒçten√≠
        localStorage.setItem('donulandLastDataLoad', new Date().toISOString());
        
        return allSheetData;
        
    } catch (error) {
        console.error('‚ùå Critical error loading Sheet data:', error);
        
        // Pokusit se naƒç√≠st z cache
        const cachedData = localStorage.getItem('donulandSheetCache');
        if (cachedData) {
            try {
                const parsed = JSON.parse(cachedData);
                console.log('üì± Using cached sheet data');
                allSheetData = parsed;
                updateSyncStatus('success', 'Pou≈æita cache data');
                return parsed;
            } catch (cacheError) {
                console.error('Cache data corrupted:', cacheError);
            }
        }
        
        throw error;
    }
}

// Vylep≈°en√° funkce pro parsov√°n√≠ CSV
function parseCSVDataImproved(csvText) {
    console.log('üîç Starting improved CSV parsing...');
    
    try {
        const lines = csvText.split(/\r?\n/).filter(line => line.trim() !== '');
        
        if (lines.length < 2) {
            throw new Error('CSV m√° m√©nƒõ ne≈æ 2 ≈ô√°dky (hlaviƒçka + data)');
        }
        
        // Parsovat hlaviƒçku
        let headers = parseCSVLineImproved(lines[0]);
        
        // Oƒçistit hlaviƒçky
        headers = headers.map(h => 
            h.trim()
             .replace(/"/g, '')
             .replace(/^\uFEFF/, '')
             .replace(/\r/g, '')
             .toLowerCase()
        );
        
        console.log('üìã Found headers:', headers);
        
        const data = [];
        let successfullyParsed = 0;
        let errors = 0;

        for (let i = 1; i < lines.length; i++) {
            try {
                if (lines[i].trim() === '') continue;
                
                const values = parseCSVLineImproved(lines[i]);
                
                if (values.length < 3) {
                    console.warn(`≈ò√°dek ${i + 1} m√° p≈ô√≠li≈° m√°lo sloupc≈Ø:`, values);
                    errors++;
                    continue;
                }

                const eventObject = {};
                headers.forEach((header, index) => {
                    if (values[index] !== undefined) {
                        eventObject[header] = values[index]
                            .replace(/"/g, '')
                            .trim()
                            .replace(/\r/g, '');
                    }
                });

                const processedEvent = parseEventFromRowImproved(eventObject, headers);

                // Validace - ud√°lost mus√≠ m√≠t alespo≈à n√°zev nebo lokaci
                if (processedEvent.eventName || processedEvent.location || 
                    processedEvent.actualSales > 0 || processedEvent.estimatedSales > 0) {
                    data.push(processedEvent);
                    successfullyParsed++;
                }
                
            } catch (rowError) {
                console.warn(`Chyba zpracov√°n√≠ ≈ô√°dku ${i + 1}:`, rowError);
                errors++;
            }
        }

        console.log(`‚úÖ CSV parsing complete: ${successfullyParsed} events parsed, ${errors} errors`);
        
        if (data.length === 0) {
            throw new Error('≈Ω√°dn√© validn√≠ ud√°losti nebyly nalezeny v CSV datech');
        }

        // Ulo≈æit do cache
        try {
            localStorage.setItem('donulandSheetCache', JSON.stringify(data));
        } catch (cacheError) {
            console.warn('Could not cache sheet data:', cacheError);
        }

        return data;
        
    } catch (error) {
        console.error('‚ùå CSV parsing failed:', error);
        throw new Error(`Chyba parsov√°n√≠ CSV: ${error.message}`);
    }
}

// Vylep≈°en√° funkce pro parsov√°n√≠ CSV ≈ô√°dku
function parseCSVLineImproved(line) {
    const result = [];
    let current = '';
    let inQuotes = false;
    let i = 0;
    
    while (i < line.length) {
        const char = line[i];
        const nextChar = line[i + 1];
        
        if (char === '"') {
            if (inQuotes && nextChar === '"') {
                // Escaped quote
                current += '"';
                i += 2;
                continue;
            } else {
                // Toggle quote state
                inQuotes = !inQuotes;
            }
        } else if (char === ',' && !inQuotes) {
            // End of field
            result.push(current.trim());
            current = '';
        } else {
            current += char;
        }
        
        i++;
    }
    
    // Add last field
    result.push(current.trim());
    return result;
}

function parseCSVData(csvText) {
    console.log('üîç Starting CSV parsing...');
    
    try {
        const lines = csvText.split('\n').filter(line => line.trim() !== '');
        
        if (lines.length < 2) {
            throw new Error('CSV m√° m√©nƒõ ne≈æ 2 ≈ô√°dky');
        }
        
        let headers = parseCSVLine(lines[0]).map(h => 
            h.trim().replace(/"/g, '').replace(/^\uFEFF/, '').replace(/\r/g, '')
        );
        
        console.log('üìã Found headers:', headers);
        
        const data = [];
        let successfullyParsed = 0;
        let errors = 0;

        for (let i = 1; i < lines.length; i++) {
            try {
                if (lines[i].trim() === '') continue;
                
                const values = parseCSVLine(lines[i]);
                
                if (values.length < Math.min(3, headers.length)) {
                    console.warn(`≈ò√°dek ${i + 1} m√° p≈ô√≠li≈° m√°lo sloupc≈Ø:`, values);
                    errors++;
                    continue;
                }

                const event = {};
                headers.forEach((header, index) => {
                    if (values[index] !== undefined) {
                        event[header] = values[index].replace(/"/g, '').trim().replace(/\r/g, '');
                    }
                });

                const processedEvent = parseEventFromRow(event, headers);

                if (processedEvent.eventName || processedEvent.location || processedEvent.actualSales > 0) {
                    data.push(processedEvent);
                    successfullyParsed++;
                }
                
            } catch (rowError) {
                console.warn(`Chyba zpracov√°n√≠ ≈ô√°dku ${i + 1}:`, rowError, lines[i]);
                errors++;
            }
        }

        console.log(`‚úÖ CSV parsing complete: ${successfullyParsed} events parsed, ${errors} errors`);
        
        if (data.length === 0) {
            throw new Error('≈Ω√°dn√© validn√≠ ud√°losti nebyly nalezeny v CSV datech');
        }

        return data;
        
    } catch (error) {
        console.error('‚ùå CSV parsing failed:', error);
        throw new Error(`Chyba parsov√°n√≠ CSV: ${error.message}`);
    }
}

function parseCSVLine(line) {
    const result = [];
    let current = '';
    let inQuotes = false;
    let i = 0;
    
    while (i < line.length) {
        const char = line[i];
        const nextChar = line[i + 1];
        
        if (char === '"') {
            if (inQuotes && nextChar === '"') {
                current += '"';
                i += 2;
                continue;
            } else {
                inQuotes = !inQuotes;
            }
        } else if (char === ',' && !inQuotes) {
            result.push(current.trim());
            current = '';
        } else {
            current += char;
        }
        
        i++;
    }
    
    result.push(current.trim());
    return result;
}

function parseEventFromRow(event, headers) {
    const getField = (possibleNames) => {
        for (let name of possibleNames) {
            for (let header of headers) {
                if (header.toLowerCase().includes(name.toLowerCase())) {
                    return event[header] || '';
                }
            }
        }
        return '';
    };

    const dateFrom = getField(['datum od', 'date from', 'start date', 'zaƒç√°tek']);
    const dateTo = getField(['datum do', 'date to', 'end date', 'konec']);
    
    const startDate = parseCSVDate(dateFrom);
    const endDate = parseCSVDate(dateTo);
    
    let duration = 1;
    if (startDate && endDate) {
        const timeDiff = endDate.getTime() - startDate.getTime();
        duration = Math.max(1, Math.ceil(timeDiff / (1000 * 3600 * 24)) + 1);
    }

    const processedEvent = {
        eventName: getField(['n√°zev akce', 'event name', 'n√°zev', 'akce']),
        location: getField(['lokalita', 'location', 'mƒõsto', 'city', 'm√≠sto']),
        category: getField(['kategorie', 'category', 'typ', 'type']),
        confirmed: getField(['potvrzeno', 'confirmed', 'potvrzen√≠', 'status']),
        
        startDate: startDate,
        endDate: endDate,
        eventDate: startDate,
        date: startDate ? startDate.toISOString().split('T')[0] : '',
        duration: duration,
        
        actualSales: parseIntSafe(getField(['skuteƒçn√Ω prodej', 'actual sales', 'prod√°no', 'sold'])),
        estimatedSales: parseIntSafe(getField(['odhad prodeje', 'estimated sales', 'odhad', 'predikce'])),
        attendance: parseIntSafe(getField(['n√°v≈°tƒõvnost', 'attendance', 'n√°v≈°tƒõvn√≠ci', 'visitors'])),
        
        rentalCost: parseFloatSafe(getField(['cena n√°jmu', 'rental cost', 'n√°jem', 'rent'])),
        transportCost: parseFloatSafe(getField(['n√°klady na cestu', 'transport cost', 'doprava'])),
        otherCosts: parseFloatSafe(getField(['ostatn√≠ n√°klady', 'other costs', 'ostatn√≠'])),
        
        rating: parseIntSafe(getField(['hodnocen√≠', 'rating', 'hodnocen√≠ akce', 'stars'])),
        competition: parseIntSafe(getField(['konkurence', 'competition', 'competitors']) || '1'),
        weather: getField(['poƒças√≠', 'weather', 'poƒças√≠ bƒõhem akce']),
        
        notes: getField(['pozn√°mka', 'notes', 'poznamky', 'comments']),
        responsiblePerson: getField(['odpovƒõdn√° osoba', 'responsible', 'zodpovƒõdn√Ω']),
        
        id: generateEventId(
            getField(['n√°zev akce', 'event name']) || 'event',
            dateFrom || new Date().toISOString(),
            getField(['lokalita', 'location']) || 'unknown'
        ),
        
        source: 'sheet',
        color: eventColors[Math.floor(Math.random() * eventColors.length)],
        rawData: event
    };

    return processedEvent;
}

function parseCSVDate(dateStr) {
    if (!dateStr || dateStr.trim() === '') return null;
    
    try {
        const cleanStr = dateStr.trim();
        
        const formats = [
            /^(\d{1,2})\.(\d{1,2})\.(\d{4})$/, // DD.MM.YYYY
            /^(\d{1,2})\/(\d{1,2})\/(\d{4})$/, // DD/MM/YYYY  
            /^(\d{4})-(\d{1,2})-(\d{1,2})$/, // YYYY-MM-DD
            /^(\d{1,2})-(\d{1,2})-(\d{4})$/, // DD-MM-YYYY
        ];
        
        for (const format of formats) {
            const match = cleanStr.match(format);
            if (match) {
                let day, month, year;
                
                if (format === formats[2]) { // YYYY-MM-DD
                    [, year, month, day] = match;
                } else { // DD.MM.YYYY, DD/MM/YYYY, DD-MM-YYYY
                    [, day, month, year] = match;
                }
                
                const date = new Date(parseInt(year), parseInt(month) - 1, parseInt(day));
                
                if (date.getFullYear() == year && 
                    date.getMonth() == month - 1 && 
                    date.getDate() == day &&
                    year >= 2020 && year <= 2030) {
                    return date;
                }
            }
        }
        
        // Excel serial date format
        const serialDate = parseFloat(cleanStr);
        if (!isNaN(serialDate) && serialDate > 44000 && serialDate < 50000) {
            const excelEpoch = new Date(1900, 0, 1);
            const date = new Date(excelEpoch.getTime() + (serialDate - 2) * 24 * 60 * 60 * 1000);
            return date;
        }
        
        const isoDate = new Date(cleanStr);
        if (!isNaN(isoDate.getTime()) && isoDate.getFullYear() >= 2020 && isoDate.getFullYear() <= 2030) {
            return isoDate;
        }
        
        console.warn('Could not parse date:', cleanStr);
        return null;
        
    } catch (error) {
        console.warn('Date parsing error:', error, 'for date string:', dateStr);
        return null;
    }
}

function loadLocalSavedEvents() {
    const saved = localStorage.getItem('donulandEvents');
    if (saved) {
        try {
            localSavedEvents = JSON.parse(saved);
            console.log(`üì± Loaded ${localSavedEvents.length} local events`);
        } catch (e) {
            console.error('Error loading local events:', e);
            localSavedEvents = [];
        }
    }
}

function loadFallbackData() {
    console.log('üìÑ Loading fallback demo data...');
    
    historicalData = [
        {
            id: 'demo1',
            eventName: 'Demo Food Festival Praha',
            location: 'Praha',
            category: 'food festival',
            eventDate: new Date('2024-05-15'),
            startDate: new Date('2024-05-15'),
            endDate: new Date('2024-05-16'),
            duration: 2,
            actualSales: 850,
            estimatedSales: 800,
            attendance: 4500,
            rating: 4,
            weather: 'sluneƒçno',
            source: 'demo'
        }
    ];
    
    plannedEvents = [];
    showMessage('Naƒçtena demo data pro testov√°n√≠', 'info');
    updateSyncStatus('success', 'Demo data naƒçtena');
}

function updateAutocompleteData() {
    // Implementace bude v ƒç√°sti 12
    console.log('üìù updateAutocompleteData() - bude implementov√°no v ƒç√°sti 12');
}

// =============================================================================
// DATA VALIDATION AND TESTING
// =============================================================================

function testAllConnections() {
    console.log('üîç Testing all API connections...');
    
    // Test Weather API
    testWeatherAPI();
    
    // Test Google Maps API
    testGoogleMapsAPI();
    
    // Test Google Sheets
    testSheetsConnection();
    
    showMessage('Testov√°n√≠ v≈°ech spojen√≠ dokonƒçeno - viz konzole pro detaily', 'info');
}

async function testWeatherAPI() {
    try {
        const testUrl = `https://api.openweathermap.org/data/2.5/weather?q=Praha,CZ&appid=${WEATHER_API_KEY}`;
        const response = await fetch(testUrl);
        
        if (response.ok) {
            document.getElementById('weatherApiStatus').innerHTML = 'üå§Ô∏è Weather API: <span style="color: #27ae60;">‚úÖ Aktivn√≠</span>';
            console.log('‚úÖ Weather API connection successful');
        } else {
            throw new Error(`HTTP ${response.status}`);
        }
    } catch (error) {
        document.getElementById('weatherApiStatus').innerHTML = 'üå§Ô∏è Weather API: <span style="color: #e74c3c;">‚ùå Chyba</span>';
        console.error('‚ùå Weather API connection failed:', error);
    }
}

function testGoogleMapsAPI() {
    if (googleMapsLoaded) {
        document.getElementById('mapsApiStatus').innerHTML = 'üó∫Ô∏è Google Maps API: <span style="color: #27ae60;">‚úÖ Aktivn√≠</span>';
        console.log('‚úÖ Google Maps API is loaded');
    } else {
        document.getElementById('mapsApiStatus').innerHTML = 'üó∫Ô∏è Google Maps API: <span style="color: #f39c12;">‚ö†Ô∏è Naƒç√≠t√° se...</span>';
        console.warn('‚ö†Ô∏è Google Maps API not yet loaded');
    }
}

async function testSheetsConnection() {
    try {
        const csvUrl = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/export?format=csv&gid=0`;
        const response = await fetch(csvUrl);
        
        if (response.ok) {
            const text = await response.text();
            if (text && text.length > 10 && !text.includes('<!DOCTYPE html>')) {
                document.getElementById('sheetApiStatus').innerHTML = 'üìä Google Sheets: <span style="color: #27ae60;">‚úÖ P≈ôipojeno</span>';
                console.log('‚úÖ Google Sheets connection successful');
            } else {
                throw new Error('Invalid CSV data received');
            }
        } else {
            throw new Error(`HTTP ${response.status}`);
        }
    } catch (error) {
        document.getElementById('sheetApiStatus').innerHTML = 'üìä Google Sheets: <span style="color: #e74c3c;">‚ùå Chyba</span>';
        console.error('‚ùå Google Sheets connection failed:', error);
    }
}

console.log('üìù ƒå√°st 5 naƒçtena - Data loading a Google Sheets integrace');
    // ƒå√ÅST 6: AI PREDIKCE A FINANƒåN√ç KALKULACE
// P≈ôidejte tuto ƒç√°st za ƒå√°st 5 v <script> tagu

// =============================================================================
// PREDICTION SYSTEM
// =============================================================================

function updatePrediction() {
    const eventType = document.getElementById('eventType').value;
    const eventName = document.getElementById('eventName').value.trim();
    const eventLocation = document.getElementById('eventLocation').value.trim();
    const expectedVisitors = parseInt(document.getElementById('expectedVisitors').value) || 0;
    const environment = document.getElementById('eventEnvironment').value;
    const duration = parseInt(document.getElementById('eventDuration').value);
    
    if (!eventType || !expectedVisitors) {
        document.getElementById('predictionResults').innerHTML = 
            '<div class="prediction-loading">üìç Vypl≈àte typ akce a n√°v≈°tƒõvnost pro naƒçten√≠ predikce</div>';
        return;
    }

    document.getElementById('predictionResults').innerHTML = 
        '<div class="prediction-loading"><div class="loading-spinner"></div> Analyzujem historick√° data a poƒç√≠t√°m predikci...</div>';

    try {
        let baseSales = calculateBaseSales(eventType, expectedVisitors, duration);
        
        let weatherFactor = 1.0;
        if (currentWeatherData && environment !== 'indoor') {
            weatherFactor = currentWeatherData.environmentImpact;
        }

        const historicalFactor = getHistoricalAdjustment(eventType, expectedVisitors, eventLocation);
        const locationFactor = getLocationAdjustment(eventLocation);
        const seasonalFactor = getSeasonalAdjustment(document.getElementById('eventDate').value);
        
        const predictedSales = Math.round(baseSales * weatherFactor * historicalFactor * locationFactor * seasonalFactor);
        const confidence = calculateConfidence(eventType, expectedVisitors, eventLocation, weatherFactor);
        
        const financials = calculateFinancials(predictedSales);
        
        lastPrediction = {
            id: generateEventId(eventName, document.getElementById('eventDate').value, eventLocation),
            eventName: eventName,
            eventType: eventType,
            location: eventLocation,
            date: document.getElementById('eventDate').value,
            duration: duration,
            expectedVisitors: expectedVisitors,
            predictedSales: predictedSales,
            confidence: confidence,
            financials: financials,
            weather: currentWeatherData,
            businessModel: document.querySelector('input[name="businessModel"]:checked').value,
            environment: environment,
            timestamp: new Date().toISOString()
        };

        displayPredictionResults(predictedSales, confidence, financials);
        
        console.log('‚úÖ Prediction calculated:', lastPrediction);

    } catch (error) {
        console.error('Prediction error:', error);
        document.getElementById('predictionResults').innerHTML = 
            '<div class="prediction-loading" style="color: #e74c3c;">‚ùå Chyba p≈ôi v√Ωpoƒçtu predikce</div>';
    }
}

function calculateBaseSales(eventType, visitors, duration) {
    const conversionRates = {
        'food festival': 0.22,
        'cokoladovy festival': 0.28,
        'rodinny festival': 0.18,
        'kulturni': 0.15,
        'ostatni': 0.12,
        'sportovni': 0.10,
        'veletrh': 0.08,
        'koncert': 0.06
    };
    
    let baseRate = conversionRates[eventType] || conversionRates['ostatni'];
    
    if (visitors > 10000) {
        baseRate *= 0.85;
    } else if (visitors > 5000) {
        baseRate *= 0.92;
    } else if (visitors < 1000) {
        baseRate *= 1.1;
    }
    
    const dailySales = visitors * baseRate;
    
    let durationFactor;
    switch(duration) {
        case 1: durationFactor = 1.0; break;
        case 2: durationFactor = 1.75; break;
        case 3: durationFactor = 2.35; break;
        case 4: durationFactor = 2.8; break;
        case 5: durationFactor = 3.1; break;
        default: durationFactor = Math.min(4.0, 1 + (duration - 1) * 0.55);
    }
    
    return Math.round(dailySales * durationFactor);
}

function getHistoricalAdjustment(eventType, visitors, location) {
    if (historicalData.length === 0) return 1.0;
    
    const similarEvents = historicalData.filter(event => {
        const typeMatch = event.category && 
            event.category.toLowerCase().includes(eventType.toLowerCase());
        const sizeMatch = Math.abs((event.attendance || 0) - visitors) / Math.max(visitors, 1) < 0.5;
        const locationMatch = !location || 
            (event.location && event.location.toLowerCase() === location.toLowerCase());
        
        return typeMatch && sizeMatch && event.actualSales > 0;
    });
    
    if (similarEvents.length === 0) return 1.0;
    
    let totalRatio = 0;
    let validEvents = 0;
    
    similarEvents.forEach(event => {
        if (event.estimatedSales && event.estimatedSales > 0) {
            const ratio = event.actualSales / event.estimatedSales;
            totalRatio += ratio;
            validEvents++;
        }
    });
    
    if (validEvents === 0) return 1.0;
    
    const avgRatio = totalRatio / validEvents;
    const confidenceWeight = Math.min(1.0, validEvents / 5);
    const adjustment = 1.0 + (avgRatio - 1.0) * confidenceWeight;
    
    return Math.max(0.5, Math.min(1.5, adjustment));
}

function getLocationAdjustment(location) {
    if (!location) return 1.0;
    
    const normalizedLocation = location.toLowerCase().trim();
    
    const cityFactors = {
        'praha': 1.25,
        'brno': 1.15,
        'ostrava': 1.1,
        'plzen': 1.08,
        'liberec': 1.05,
        'olomouc': 1.05
    };
    
    const touristFactors = {
        'karlovy vary': 1.2,
        'cesky krumlov': 1.2,
        'marianske lazne': 1.15
    };
    
    for (const [city, factor] of Object.entries(cityFactors)) {
        if (normalizedLocation.includes(city)) {
            return factor;
        }
    }
    
    for (const [destination, factor] of Object.entries(touristFactors)) {
        if (normalizedLocation.includes(destination)) {
            return factor;
        }
    }
    
    return 1.0;
}

function getSeasonalAdjustment(dateStr) {
    if (!dateStr) return 1.0;
    
    const date = new Date(dateStr);
    const month = date.getMonth() + 1;
    
    if (month >= 6 && month <= 8) {
        return 1.2; // Summer peak
    } else if (month >= 4 && month <= 5) {
        return 1.1; // Spring
    } else if (month >= 9 && month <= 10) {
        return 1.15; // Early fall
    } else if (month === 12) {
        return 1.1; // Christmas markets
    } else {
        return 0.85; // Winter
    }
}

function calculateConfidence(eventType, visitors, location, weatherFactor) {
    let confidence = 30;
    
    const typeEvents = historicalData.filter(event => 
        event.category && event.category.toLowerCase().includes(eventType.toLowerCase())
    );
    confidence += Math.min(30, typeEvents.length * 2.5);
    
    const locationEvents = historicalData.filter(event => 
        event.location && event.location.toLowerCase() === location.toLowerCase()
    );
    confidence += Math.min(20, locationEvents.length * 3);
    
    if (visitors >= 500 && visitors <= 10000) {
        confidence += 12;
    } else if (visitors >= 200 && visitors <= 20000) {
        confidence += 8;
    } else {
        confidence += 3;
    }
    
    if (currentWeatherData) {
        confidence += 8;
        if (Math.abs(weatherFactor - 1.0) > 0.3) {
            confidence -= 5;
        }
    }
    
    const recentEvents = historicalData.filter(event => {
        const eventDate = new Date(event.eventDate || event.date);
        const monthsAgo = (new Date() - eventDate) / (1000 * 60 * 60 * 24 * 30);
        return monthsAgo <= 12;
    });
    confidence += Math.min(10, recentEvents.length * 0.5);
    
    return Math.max(15, Math.min(85, Math.round(confidence)));
}

// =============================================================================
// FINANCIAL CALCULATIONS
// =============================================================================

function calculateFinancials(predictedSales) {
    const businessModel = document.querySelector('input[name="businessModel"]:checked').value;
    const donutCost = parseFloat(document.getElementById('donutCost').value) || 32;
    const sellingPrice = parseFloat(document.getElementById('sellingPrice').value) || 110;
    const transportCost = parseFloat(document.getElementById('transportCost').value) || 500;
    const otherCosts = parseFloat(document.getElementById('otherCosts').value) || 0;
    
    let financials = {};
    
    if (businessModel === 'owner') {
        financials = calculateOwnerFinancials(predictedSales, donutCost, sellingPrice, transportCost, otherCosts);
    } else if (businessModel === 'employee') {
        financials = calculateEmployeeFinancials(predictedSales, donutCost, sellingPrice, transportCost, otherCosts);
    } else if (businessModel === 'franchisee') {
        financials = calculateFranchiseeFinancials(predictedSales, donutCost, sellingPrice, transportCost, otherCosts);
    }
    
    financials.revenue = predictedSales * sellingPrice;
    financials.margin = financials.revenue > 0 ? (financials.profit / financials.revenue) * 100 : 0;
    financials.profitPerDonut = predictedSales > 0 ? financials.profit / predictedSales : 0;
    
    return financials;
}

function calculateOwnerFinancials(predictedSales, donutCost, sellingPrice, transportCost, otherCosts) {
    const laborCost = 3000; // 2 brig√°dn√≠ci
    const donutsCost = predictedSales * donutCost;
    const rentalCost = calculateRentalCost(predictedSales * sellingPrice);
    
    const totalCosts = donutsCost + transportCost + otherCosts + laborCost + rentalCost;
    const profit = (predictedSales * sellingPrice) - totalCosts;
    
    const fixedCosts = transportCost + otherCosts + laborCost + 
                      (document.getElementById('rentalModel')?.value === 'fixed' ? rentalCost : 0);
    const variableCostPerUnit = donutCost + 
                               (document.getElementById('rentalModel')?.value === 'percentage' ? 
                                (sellingPrice * parseFloat(document.getElementById('percentageRental')?.value || 0) / 100) : 0);
    const contributionPerUnit = sellingPrice - variableCostPerUnit;
    const breakEvenUnits = contributionPerUnit > 0 ? Math.ceil(fixedCosts / contributionPerUnit) : 0;
    
    return {
        totalCosts,
        donutsCost,
        laborCost,
        transportCost,
        otherCosts,
        rentalCost,
        profit,
        breakEvenUnits,
        costBreakdown: {
            'Donuty': donutsCost,
            'Pr√°ce (2 brig√°dn√≠ci)': laborCost,
            'Doprava': transportCost,
            'N√°jem': rentalCost,
            'Ostatn√≠': otherCosts
        }
    };
}

function calculateEmployeeFinancials(predictedSales, donutCost, sellingPrice, transportCost, otherCosts) {
    const brigadeLabor = 1500;
    const ownWage = 1500;
    const revenue = predictedSales * sellingPrice;
    const revenueShare = revenue * 0.05;
    
    const totalLaborCost = brigadeLabor + ownWage + revenueShare;
    const donutsCost = predictedSales * donutCost;
    const rentalCost = calculateRentalCost(revenue);
    
    const totalCosts = donutsCost + transportCost + otherCosts + totalLaborCost + rentalCost;
    const profit = revenue - totalCosts;
    
    return {
        totalCosts,
        donutsCost,
        laborCost: totalLaborCost,
        transportCost,
        otherCosts,
        rentalCost,
        profit,
        revenueShare,
        costBreakdown: {
            'Donuty': donutsCost,
            'Brig√°dn√≠k': brigadeLabor,
            'Vlastn√≠ mzda': ownWage,
            'Pod√≠l z obratu (5%)': revenueShare,
            'Doprava': transportCost,
            'N√°jem': rentalCost,
            'Ostatn√≠': otherCosts
        }
    };
}

function calculateFranchiseeFinancials(predictedSales, donutCost, sellingPrice, transportCost, otherCosts) {
    const franchisePrice = 52;
    const productionCost = 32;
    const yourProfit = (franchisePrice - productionCost) * predictedSales;
    
    const franchiseeRevenue = predictedSales * sellingPrice;
    const franchiseeDonutCost = predictedSales * franchisePrice;
    const rentalCost = calculateRentalCost(franchiseeRevenue);
    
    const franchiseeTotalCosts = franchiseeDonutCost + transportCost + otherCosts + rentalCost;
    const franchiseeProfit = franchiseeRevenue - franchiseeTotalCosts;
    
    return {
        yourRevenue: franchisePrice * predictedSales,
        yourCosts: productionCost * predictedSales,
        yourProfit: yourProfit,
        totalCosts: franchiseeTotalCosts,
        donutsCost: franchiseeDonutCost,
        laborCost: 0,
        transportCost,
        otherCosts,
        rentalCost,
        profit: franchiseeProfit,
        breakEvenUnits: sellingPrice > franchisePrice ? 
                       Math.ceil((transportCost + otherCosts + rentalCost) / (sellingPrice - franchisePrice)) : 0,
        costBreakdown: {
            'N√°kup donut≈Ø (fran≈°√≠zant)': franchiseeDonutCost,
            'Doprava (fran≈°√≠zant)': transportCost,
            'N√°jem (fran≈°√≠zant)': rentalCost,
            'Ostatn√≠ (fran≈°√≠zant)': otherCosts,
            'V√°≈° zisk z prodeje': yourProfit
        }
    };
}

function calculateRentalCost(revenue) {
    const rentalModel = document.getElementById('rentalModel')?.value || 'fixed';
    let rentalCost = 0;
    
    if (rentalModel === 'fixed') {
        rentalCost = parseFloat(document.getElementById('fixedRental')?.value) || 5000;
    } else if (rentalModel === 'percentage') {
        const percentage = parseFloat(document.getElementById('percentageRental')?.value) || 15;
        rentalCost = revenue * (percentage / 100);
    } else if (rentalModel === 'mixed') {
        const fixed = parseFloat(document.getElementById('fixedRental')?.value) || 2500;
        const percentage = parseFloat(document.getElementById('percentageRental')?.value) || 10;
        rentalCost = fixed + (revenue * (percentage / 100));
    }
    
    return rentalCost;
}

// =============================================================================
// PREDICTION DISPLAY AND INTERACTION
// =============================================================================

function displayPredictionResults(predictedSales, confidence, financials) {
    const resultsDiv = document.getElementById('predictionResults');
    const businessModel = document.querySelector('input[name="businessModel"]:checked').value;
    
    let confidenceClass = 'confidence-low';
    let confidenceText = 'N√≠zk√°';
    let confidenceColor = '#e17055';
    
    if (confidence > 75) {
        confidenceClass = 'confidence-high';
        confidenceText = 'Vysok√°';
        confidenceColor = '#00b894';
    } else if (confidence > 50) {
        confidenceClass = 'confidence-medium';
        confidenceText = 'St≈ôedn√≠';
        confidenceColor = '#fdcb6e';
    }
    
    let summaryHtml = '';
    let detailsHtml = '';
    
    if (businessModel === 'franchisee') {
        summaryHtml = `
            <div class="prediction-summary">
                <div class="prediction-metric">
                    <div class="metric-value">${predictedSales.toLocaleString('cs-CZ')}</div>
                    <div class="metric-label">Predikce prodeje (ks)</div>
                </div>
                <div class="prediction-metric">
                    <div class="metric-value">${Math.round(financials.yourRevenue || 0).toLocaleString('cs-CZ')} Kƒç</div>
                    <div class="metric-label">V√°≈° obrat z prodeje</div>
                </div>
                <div class="prediction-metric">
                    <div class="metric-value" style="color: #00b894">
                        ${Math.round(financials.yourProfit || 0).toLocaleString('cs-CZ')} Kƒç
                    </div>
                    <div class="metric-label">V√°≈° ƒçist√Ω zisk</div>
                </div>
                <div class="prediction-metric">
                    <div class="metric-value" style="color: ${financials.profit >= 0 ? '#00b894' : '#e17055'}">
                        ${Math.round(financials.profit || 0).toLocaleString('cs-CZ')} Kƒç
                    </div>
                    <div class="metric-label">Zisk fran≈°√≠zanta</div>
                </div>
            </div>
        `;
    } else {
        summaryHtml = `
            <div class="prediction-summary">
                <div class="prediction-metric">
                    <div class="metric-value">${predictedSales.toLocaleString('cs-CZ')}</div>
                    <div class="metric-label">Predikce prodeje (ks)</div>
                </div>
                <div class="prediction-metric">
                    <div class="metric-value">${Math.round(financials.revenue || 0).toLocaleString('cs-CZ')} Kƒç</div>
                    <div class="metric-label">Oƒçek√°van√Ω obrat</div>
                </div>
                <div class="prediction-metric">
                    <div class="metric-value" style="color: ${financials.profit >= 0 ? '#00b894' : '#e17055'}">
                        ${Math.round(financials.profit || 0).toLocaleString('cs-CZ')} Kƒç
                    </div>
                    <div class="metric-label">Oƒçek√°van√Ω zisk</div>
                </div>
                <div class="prediction-metric">
                    <div class="metric-value">${financials.margin.toFixed(1)}%</div>
                    <div class="metric-label">Ziskov√° mar≈æe</div>
                </div>
            </div>
        `;
    }
    
    detailsHtml = `
        <div style="background: rgba(255, 255, 255, 0.2); padding: 15px; border-radius: 6px;">
            <h5 style="margin: 0 0 10px 0;">üí∞ Detailn√≠ rozpis n√°klad≈Ø:</h5>
            <div style="display: grid; gap: 8px; font-size: 0.95em;">
    `;
    
    if (financials.costBreakdown) {
        Object.entries(financials.costBreakdown).forEach(([category, cost]) => {
            detailsHtml += `<div>${getCategoryIcon(category)} ${category}: ${Math.round(cost).toLocaleString('cs-CZ')} Kƒç</div>`;
        });
    }
    
    detailsHtml += `
                <div style="border-top: 1px solid rgba(255,255,255,0.3); padding-top: 5px; margin-top: 5px;">
                    <strong>üí∏ Celkov√© n√°klady: ${Math.round(financials.totalCosts || 0).toLocaleString('cs-CZ')} Kƒç</strong>
                </div>
                <div>üìä Break-even bod: ${financials.breakEvenUnits || 0} ks</div>
                <div>üç© Zisk na donut: ${financials.profitPerDonut.toFixed(1)} Kƒç</div>
            </div>
        </div>
    `;
    
    resultsDiv.innerHTML = `
        ${summaryHtml}
        
        <div style="margin-top: 20px;">
            <strong>Spolehlivost predikce: ${confidenceText} (${confidence}%)</strong>
            <div class="confidence-bar">
                <div class="confidence-fill ${confidenceClass}" style="width: ${confidence}%"></div>
            </div>
            ${getConfidenceExplanation(confidence)}
        </div>
        
        ${detailsHtml}
        
        <div style="margin-top: 20px; text-align: center;">
            <button class="btn btn-success btn-large" onclick="saveCurrentPrediction()" style="margin-right: 10px;">
                üìÖ Ulo≈æit do kalend√°≈ôe
            </button>
            <button class="btn btn-primary" onclick="showManualOverride()" style="background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3);">
                ‚úèÔ∏è Upravit predikci
            </button>
        </div>
    `;
}

function getCategoryIcon(category) {
    const icons = {
        'Donuty': 'üì¶',
        'Pr√°ce (2 brig√°dn√≠ci)': 'üë•',
        'Brig√°dn√≠k': 'üë∑',
        'Vlastn√≠ mzda': 'üíº',
        'Pod√≠l z obratu (5%)': 'üìà',
        'Doprava': 'üöö',
        'N√°jem': 'üè™',
        'Ostatn√≠': 'üíº',
        'N√°kup donut≈Ø (fran≈°√≠zant)': 'üì¶',
        'Doprava (fran≈°√≠zant)': 'üöö',
        'N√°jem (fran≈°√≠zant)': 'üè™',
        'Ostatn√≠ (fran≈°√≠zant)': 'üíº',
        'V√°≈° zisk z prodeje': 'üíé'
    };
    return icons[category] || 'üí∞';
}

function getConfidenceExplanation(confidence) {
    if (confidence > 75) {
        return '<div style="font-size: 0.9em; margin-top: 5px; opacity: 0.9;">Dostatek podobn√Ωch historick√Ωch dat pro p≈ôesnou predikci</div>';
    } else if (confidence > 50) {
        return '<div style="font-size: 0.9em; margin-top: 5px; opacity: 0.9;">Omezen√° historick√° data, predikce zalo≈æen√° na obecn√Ωch trendech</div>';
    } else {
        return '<div style="font-size: 0.9em; margin-top: 5px; opacity: 0.9;">M√°lo dat pro tento typ akce, doporuƒçujeme opatrnost</div>';
    }
}

function saveCurrentPrediction() {
    if (!lastPrediction) {
        showMessage('Nejprve vytvo≈ôte predikci', 'error');
        return;
    }
    
    try {
        const existingIndex = localSavedEvents.findIndex(e => e.id === lastPrediction.id);
        
        if (existingIndex >= 0) {
            localSavedEvents[existingIndex] = lastPrediction;
            showMessage('Predikce byla aktualizov√°na v kalend√°≈ôi', 'success');
        } else {
            localSavedEvents.push(lastPrediction);
            showMessage('Predikce byla √∫spƒõ≈°nƒõ ulo≈æena do kalend√°≈ôe', 'success');
        }
        
        localStorage.setItem('donulandEvents', JSON.stringify(localSavedEvents));
        updateAutocompleteData();
        
    } catch (error) {
        console.error('Save prediction error:', error);
        showMessage('Chyba p≈ôi ukl√°d√°n√≠ predikce', 'error');
    }
}

function showManualOverride() {
    if (!lastPrediction) {
        showMessage('Nejprve vytvo≈ôte predikci', 'error');
        return;
    }
    
    const currentResults = document.getElementById('predictionResults');
    const overrideHtml = `
        <div style="background: rgba(255, 255, 255, 0.15); padding: 15px; border-radius: 8px; margin-top: 15px; backdrop-filter: blur(10px);">
            <h5 style="margin: 0 0 15px 0; font-size: 1.1em;">‚úèÔ∏è Upravit predikci</h5>
            <div style="display: grid; gap: 15px;">
                <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                    <label style="min-width: 150px;">V√°≈° odhad prodeje (ks):</label>
                    <input type="number" id="manualPrediction" value="${lastPrediction.predictedSales}" min="0" step="1" 
                           style="width: 120px; padding: 8px 12px; border: none; border-radius: 4px; background: rgba(255, 255, 255, 0.9); color: #333;">
                </div>
                <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                    <label style="min-width: 150px;">D≈Øvod √∫pravy:</label>
                    <select id="overrideReason" style="width: 200px; padding: 8px 12px; border: none; border-radius: 4px; background: rgba(255, 255, 255, 0.9); color: #333;">
                        <option value="experience">Osobn√≠ zku≈°enost</option>
                        <option value="local_knowledge">M√≠stn√≠ znalost</option>
                        <option value="organizer_info">Info od organiz√°tora</option>
                        <option value="weather_concern">Obavy z poƒças√≠</option>
                        <option value="competition">Konkurence na m√≠stƒõ</option>
                        <option value="other">Jin√Ω d≈Øvod</option>
                    </select>
                </div>
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <button onclick="applyManualOverride()" 
                            style="background: rgba(255, 255, 255, 0.25); color: white; border: 1px solid rgba(255, 255, 255, 0.3); padding: 8px 15px; border-radius: 4px; cursor: pointer;">
                        ‚úÖ Pou≈æ√≠t √∫pravu
                    </button>
                    <button onclick="cancelManualOverride()" 
                            style="background: rgba(231, 76, 60, 0.2); color: white; border: 1px solid #e74c3c; padding: 8px 15px; border-radius: 4px; cursor: pointer;">
                        ‚ùå Zru≈°it
                    </button>
                </div>
            </div>
        </div>
    `;
    
    currentResults.innerHTML += overrideHtml;
}

function applyManualOverride() {
    const manualValue = parseInt(document.getElementById('manualPrediction').value);
    const reason = document.getElementById('overrideReason').value;
    
    if (isNaN(manualValue) || manualValue < 0) {
        showMessage('Zadejte platnou hodnotu', 'error');
        return;
    }
    
    const financials = calculateFinancials(manualValue);
    
    if (lastPrediction) {
        lastPrediction.predictedSales = manualValue;
        lastPrediction.confidence = 100;
        lastPrediction.financials = financials;
        lastPrediction.isManualOverride = true;
        lastPrediction.overrideReason = reason;
        lastPrediction.originalPrediction = lastPrediction.predictedSales;
    }
    
    displayPredictionResults(manualValue, 100, financials);
    
    const reasonTexts = {
        'experience': 'na z√°kladƒõ osobn√≠ zku≈°enosti',
        'local_knowledge': 'na z√°kladƒõ m√≠stn√≠ znalosti',
        'organizer_info': 'podle informac√≠ od organiz√°tora',
        'weather_concern': 'kv≈Øli obav√°m z poƒças√≠',
        'competition': 'kv≈Øli konkurenci na m√≠stƒõ',
        'other': 'z jin√©ho d≈Øvodu'
    };
    
    showMessage(`Predikce byla upravena ${reasonTexts[reason] || 'ruƒçnƒõ'}`, 'success');
}

function cancelManualOverride() {
    if (lastPrediction) {
        displayPredictionResults(
            lastPrediction.predictedSales, 
            lastPrediction.confidence, 
            lastPrediction.financials
        );
    }
}

console.log('üìù ƒå√°st 6 naƒçtena - AI Predikce a finanƒçn√≠ kalkulace');
    // ƒå√ÅST 7: WEATHER API A GOOGLE MAPS INTEGRACE
// P≈ôidejte tuto ƒç√°st za ƒå√°st 6 v <script> tagu

// === OPRAVA NAƒå√çT√ÅN√ç POƒåAS√ç ===
async function loadWeather() {
    const location = document.getElementById('eventLocation');
    const date = document.getElementById('eventDate');
    const duration = document.getElementById('eventDuration');
    const environment = document.getElementById('eventEnvironment');
    
    if (!location || !date || !duration || !environment) {
        console.error('Weather form elements not found');
        return;
    }
    
    const locationValue = location.value.trim();
    const dateValue = date.value;
    const durationValue = parseInt(duration.value) || 1;
    const environmentValue = environment.value;
    
    if (!locationValue || !dateValue) {
        const weatherDisplay = document.getElementById('weatherDisplay');
        if (weatherDisplay) {
            weatherDisplay.innerHTML = '<div class="weather-loading">üìç Vyberte mƒõsto a datum pro naƒçten√≠ poƒças√≠</div>';
        }
        return;
    }

    const weatherDisplay = document.getElementById('weatherDisplay');
    const qualityWarning = document.getElementById('qualityWarning');
    
    if (weatherDisplay) {
        weatherDisplay.innerHTML = '<div class="weather-loading">üîÑ Naƒç√≠t√°m p≈ôedpovƒõƒè poƒças√≠...</div>';
    }
    if (qualityWarning) {
        qualityWarning.style.display = 'none';
    }

    try {
        console.log(`üåç Loading weather for: ${locationValue}, date: ${dateValue}, duration: ${durationValue}`);
        
        // Z√≠skat sou≈ôadnice mƒõsta
        const geoUrl = `https://api.openweathermap.org/geo/1.0/direct?q=${encodeURIComponent(locationValue)},CZ&limit=3&appid=${WEATHER_API_KEY}`;
        
        console.log('üîç Geocoding URL:', geoUrl);
        
        const geoResponse = await fetch(geoUrl);
        
        if (!geoResponse.ok) {
            throw new Error(`Geocoding API error: ${geoResponse.status}`);
        }
        
        const geoData = await geoResponse.json();
        console.log('üåç Geocoding response:', geoData);
        
        if (!geoData || geoData.length === 0) {
            throw new Error(`Mƒõsto "${locationValue}" nenalezeno`);
        }

        // Preferovat ƒçeskou lokaci
        const czechLocation = geoData.find(loc => loc.country === 'CZ') || geoData[0];
        const lat = czechLocation.lat;
        const lon = czechLocation.lon;

        console.log(`üìç Found location: ${czechLocation.name}, ${czechLocation.country} (${lat}, ${lon})`);

        // Aktualizovat n√°klady na dopravu
        await updateTransportCostImproved(lat, lon);

        // Naƒç√≠st poƒças√≠
        const weatherUrl = `https://api.openweathermap.org/data/2.5/forecast?lat=${lat}&lon=${lon}&appid=${WEATHER_API_KEY}&units=metric&lang=cs`;
        
        console.log('üå§Ô∏è Weather URL:', weatherUrl);
        
        const weatherResponse = await fetch(weatherUrl);
        
        if (!weatherResponse.ok) {
            throw new Error(`Weather API error: ${weatherResponse.status} - ${weatherResponse.statusText}`);
        }
        
        const weatherData = await weatherResponse.json();
        console.log('üå§Ô∏è Weather response:', weatherData);

        if (!weatherData.list || weatherData.list.length === 0) {
            throw new Error('≈Ω√°dn√° data o poƒças√≠ nejsou dostupn√°');
        }

        const eventDate = new Date(dateValue);
        const weatherSummary = processWeatherDataImproved(weatherData, eventDate, durationValue, environmentValue);
        
        displayWeatherResultsImproved(weatherSummary, locationValue, durationValue, environmentValue);
        
        currentWeatherData = weatherSummary;
        
        // P≈ôepoƒç√≠tat predikci s nov√Ωmi √∫daji o poƒças√≠
        setTimeout(() => {
            updatePrediction();
        }, 100);

    } catch (error) {
        console.error('Weather error:', error);
        
        if (weatherDisplay) {
            weatherDisplay.innerHTML = `
                <div style="color: #e74c3c; padding: 15px; border-radius: 8px; background: rgba(231, 76, 60, 0.1);">
                    <div style="font-weight: bold; margin-bottom: 8px;">‚ö†Ô∏è Nepoda≈ôilo se naƒç√≠st poƒças√≠</div>
                    <div style="font-size: 0.9em; margin-bottom: 10px;">Lokalita: ${locationValue}</div>
                    <div style="font-size: 0.8em; color: #c0392b;">${error.message}</div>
                    <button onclick="loadWeather()" class="btn btn-primary" style="margin-top: 10px; font-size: 0.9em; padding: 6px 12px;">
                        üîÑ Zkusit znovu
                    </button>
                </div>
            `;
        }
        
        // Nastavit neutr√°ln√≠ poƒças√≠ pro predikci
        currentWeatherData = {
            environmentImpact: 1.0,
            avgTemp: 20,
            totalRain: 0,
            qualityRisk: false
        };
    }
}

// Vylep≈°en√° funkce pro aktualizaci dopravn√≠ch n√°klad≈Ø
async function updateTransportCostImproved(lat, lon) {
    try {
        const distance = calculateDistanceImproved(50.0755, 14.4378, lat, lon); // Praha coords
        const transportRate = parseFloat(document.getElementById('defaultTransportRate')?.value) || 
                            parseFloat(localStorage.getItem('donulandSettings') ? 
                            JSON.parse(localStorage.getItem('donulandSettings')).defaultTransportRate : 10) || 10;
        
        const baseCost = 200; // Z√°kladn√≠ n√°klady
        const distanceCost = distance * 2 * transportRate; // Tam a zpƒõt
        const totalCost = Math.round(baseCost + distanceCost);
        const finalCost = Math.min(totalCost, 8000); // Maximum 8000 Kƒç
        
        const transportInput = document.getElementById('transportCost');
        if (transportInput) {
            transportInput.value = finalCost;
        }
        
        console.log(`üöö Transport cost calculated: ${distance.toFixed(1)}km = ${finalCost} Kƒç (rate: ${transportRate} Kƒç/km)`);
        
    } catch (error) {
        console.error('Transport cost calculation error:', error);
    }
}

// Vylep≈°en√° funkce pro v√Ωpoƒçet vzd√°lenosti
function calculateDistanceImproved(lat1, lon1, lat2, lon2) {
    const R = 6371; // Polomƒõr Zemƒõ v km
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const a = 
        Math.sin(dLat/2) * Math.sin(dLat/2) +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
        Math.sin(dLon/2) * Math.sin(dLon/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c;
}

// Vylep≈°en√° funkce pro zpracov√°n√≠ dat o poƒças√≠
function processWeatherDataImproved(weatherData, eventDate, duration, environment) {
    let totalTemp = 0;
    let totalRain = 0;
    let maxTemp = -Infinity;
    let minTemp = Infinity;
    let validDays = 0;
    
    const tempThreshold = parseInt(document.getElementById('qualityTempThreshold')?.value) || 
                         JSON.parse(localStorage.getItem('donulandSettings') || '{}').qualityTempThreshold || 28;

    const weatherSummary = {
        avgTemp: 0,
        maxTemp: 0,
        minTemp: 0,
        totalRain: 0,
        weatherConditions: [],
        dayDetails: [],
        qualityRisk: false,
        environmentImpact: 1.0
    };

    for (let day = 0; day < duration; day++) {
        const currentDate = new Date(eventDate);
        currentDate.setDate(eventDate.getDate() + day);
        
        // Naj√≠t data pro tento den
        const dayData = weatherData.list.filter(item => {
            const itemDate = new Date(item.dt * 1000);
            return itemDate.toDateString() === currentDate.toDateString();
        });

        if (dayData.length > 0) {
            const dayTemp = dayData.reduce((sum, item) => sum + item.main.temp, 0) / dayData.length;
            const dayMaxTemp = Math.max(...dayData.map(item => item.main.temp_max));
            const dayMinTemp = Math.min(...dayData.map(item => item.main.temp_min));
            const dayRain = dayData.reduce((sum, item) => sum + (item.rain?.['3h'] || 0), 0);
            const dayWeather = dayData[Math.floor(dayData.length / 2)].weather[0];

            totalTemp += dayTemp;
            totalRain += dayRain;
            maxTemp = Math.max(maxTemp, dayMaxTemp);
            minTemp = Math.min(minTemp, dayMinTemp);
            validDays++;
            
            const hasQualityRisk = dayMaxTemp > tempThreshold && environment !== 'indoor';
            if (hasQualityRisk) {
                weatherSummary.qualityRisk = true;
            }

            weatherSummary.weatherConditions.push(dayWeather.description);
            weatherSummary.dayDetails.push({
                day: day + 1,
                date: currentDate,
                temp: dayTemp,
                maxTemp: dayMaxTemp,
                minTemp: dayMinTemp,
                rain: dayRain,
                description: dayWeather.description,
                icon: dayWeather.icon,
                qualityRisk: hasQualityRisk
            });
        }
    }

    if (validDays > 0) {
        weatherSummary.avgTemp = totalTemp / validDays;
        weatherSummary.maxTemp = maxTemp;
        weatherSummary.minTemp = minTemp;
        weatherSummary.totalRain = totalRain;
        weatherSummary.environmentImpact = calculateEnvironmentImpactImproved(weatherSummary, environment);
    }

    return weatherSummary;
}

// Vylep≈°en√° funkce pro v√Ωpoƒçet vlivu poƒças√≠
function calculateEnvironmentImpactImproved(weatherSummary, environment) {
    let impact = 1.0;
    
    // Vnit≈ôn√≠ akce - minim√°ln√≠ vliv poƒças√≠
    if (environment === 'indoor') {
        // M√≠rn√Ω pozitivn√≠ vliv de≈°tƒõ (lid√© jdou dovnit≈ô)
        if (weatherSummary.totalRain > 10) {
            impact *= 1.05;
        }
        return Math.max(0.95, Math.min(1.1, impact));
    }
    
    // Vliv teploty
    if (weatherSummary.avgTemp < 8) {
        impact *= 0.75; // Velmi chladno
    } else if (weatherSummary.avgTemp < 15) {
        impact *= 0.85; // Chladno
    } else if (weatherSummary.avgTemp > 32) {
        impact *= 0.8; // Velmi horko
    } else if (weatherSummary.avgTemp > 28) {
        impact *= 0.9; // Horko
    } else if (weatherSummary.avgTemp >= 18 && weatherSummary.avgTemp <= 25) {
        impact *= 1.15; // Ide√°ln√≠ teplota
    }
    
    // Vliv de≈°tƒõ
    if (weatherSummary.totalRain > 20) {
        impact *= 0.5; // Siln√Ω d√©≈°≈•
    } else if (weatherSummary.totalRain > 10) {
        impact *= 0.7; // St≈ôedn√≠ d√©≈°≈•
    } else if (weatherSummary.totalRain > 3) {
        impact *= 0.85; // Slab√Ω d√©≈°≈•
    } else if (weatherSummary.totalRain < 1) {
        impact *= 1.05; // Such√© poƒças√≠
    }
    
    // Vliv kvality (vysok√© teploty)
    if (weatherSummary.qualityRisk) {
        impact *= 0.9; // Riziko kvality donut≈Ø
    }
    
    return Math.max(0.4, Math.min(1.4, impact));
}

function processWeatherData(weatherData, eventDate, duration, environment) {
    let totalTemp = 0;
    let totalRain = 0;
    let maxTemp = -Infinity;
    let minTemp = Infinity;
    let weatherSummary = {
        avgTemp: 0,
        maxTemp: 0,
        minTemp: 0,
        totalRain: 0,
        weatherConditions: [],
        dayDetails: [],
        qualityRisk: false,
        environmentImpact: 1.0
    };

    const tempThreshold = parseInt(document.getElementById('qualityTempThreshold')?.value) || 28;

    for (let day = 0; day < duration; day++) {
        const currentDate = new Date(eventDate);
        currentDate.setDate(eventDate.getDate() + day);
        
        const dayData = weatherData.list.filter(item => {
            const itemDate = new Date(item.dt * 1000);
            return itemDate.toDateString() === currentDate.toDateString();
        });

        if (dayData.length > 0) {
            const dayTemp = dayData.reduce((sum, item) => sum + item.main.temp, 0) / dayData.length;
            const dayMaxTemp = Math.max(...dayData.map(item => item.main.temp_max));
            const dayMinTemp = Math.min(...dayData.map(item => item.main.temp_min));
            const dayRain = dayData.reduce((sum, item) => sum + (item.rain?.['3h'] || 0), 0);
            const dayWeather = dayData[Math.floor(dayData.length / 2)].weather[0];

            totalTemp += dayTemp;
            totalRain += dayRain;
            maxTemp = Math.max(maxTemp, dayMaxTemp);
            minTemp = Math.min(minTemp, dayMinTemp);
            
            const hasQualityRisk = dayMaxTemp > tempThreshold && environment !== 'indoor';
            if (hasQualityRisk) {
                weatherSummary.qualityRisk = true;
            }

            weatherSummary.weatherConditions.push(dayWeather.description);
            weatherSummary.dayDetails.push({
                day: day + 1,
                date: currentDate,
                temp: dayTemp,
                maxTemp: dayMaxTemp,
                minTemp: dayMinTemp,
                rain: dayRain,
                description: dayWeather.description,
                icon: dayWeather.icon,
                qualityRisk: hasQualityRisk
            });
        }
    }

    weatherSummary.avgTemp = totalTemp / duration;
    weatherSummary.maxTemp = maxTemp;
    weatherSummary.minTemp = minTemp;
    weatherSummary.totalRain = totalRain;
    weatherSummary.environmentImpact = calculateEnvironmentImpact(weatherSummary, environment);

    return weatherSummary;
}

function calculateEnvironmentImpact(weatherSummary, environment) {
    let impact = 1.0;
    
    if (environment === 'indoor') {
        return Math.max(0.9, Math.min(1.1, 1.0 + (weatherSummary.totalRain > 10 ? 0.1 : 0)));
    }
    
    if (weatherSummary.avgTemp < 10) {
        impact *= 0.8;
    } else if (weatherSummary.avgTemp > 30) {
        impact *= 0.85;
    } else if (weatherSummary.avgTemp >= 18 && weatherSummary.avgTemp <= 25) {
        impact *= 1.1;
    }
    
    if (weatherSummary.totalRain > 15) {
        impact *= 0.6;
    } else if (weatherSummary.totalRain > 5) {
        impact *= 0.8;
    } else if (weatherSummary.totalRain < 2) {
        impact *= 1.05;
    }
    
    if (weatherSummary.qualityRisk) {
        impact *= 0.9;
    }
    
    return Math.max(0.5, Math.min(1.3, impact));
}

// === FIN√ÅLN√ç OPRAVY - ZOBRAZEN√ç POƒåAS√ç ===
function displayWeatherResultsImproved(weatherSummary, location, duration, environment) {
    const weatherDisplay = document.getElementById('weatherDisplay');
    const qualityWarning = document.getElementById('qualityWarning');
    
    if (!weatherDisplay) {
        console.error('Weather display element not found');
        return;
    }
    
    const impactText = getWeatherImpactTextImproved(weatherSummary.environmentImpact);
    
    let weatherHTML = `
        <h5>üìç ${location} - P≈ôedpovƒõƒè na ${duration} ${duration === 1 ? 'den' : duration < 5 ? 'dny' : 'dn√≠'}</h5>
        <div style="margin: 10px 0; line-height: 1.6;">
            <div><strong>üå°Ô∏è Teploty:</strong> ${weatherSummary.minTemp.toFixed(1)}¬∞C - ${weatherSummary.maxTemp.toFixed(1)}¬∞C (pr≈Ømƒõr ${weatherSummary.avgTemp.toFixed(1)}¬∞C)</div>
            <div><strong>üíß Celkov√© sr√°≈æky:</strong> ${weatherSummary.totalRain.toFixed(1)} mm</div>
            <div><strong>üìà Dopad na prodej:</strong> <span style="color: ${impactText.color}; font-weight: bold;">${impactText.text}</span></div>
            ${environment === 'indoor' ? '<div style="opacity: 0.8; font-style: italic;">üè¢ Vnit≈ôn√≠ akce - sn√≠≈æen√Ω vliv poƒças√≠</div>' : ''}
        </div>
    `;
    
    // P≈ôidat denn√≠ p≈ôehled pokud je v√≠ce ne≈æ 1 den
    if (duration > 1 && weatherSummary.dayDetails && weatherSummary.dayDetails.length > 0) {
        weatherHTML += '<div class="weather-days" style="margin-top: 15px; display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px;">';
        
        weatherSummary.dayDetails.forEach(day => {
            const qualityRiskClass = day.qualityRisk ? 'quality-risk' : '';
            let impactClass = 'positive';
            
            if (day.rain > 10) {
                impactClass = 'negative';
            } else if (day.temp < 15 || day.temp > 30 || day.rain > 5) {
                impactClass = 'warning';
            }
            
            const borderColor = day.qualityRisk ? '#e74c3c' : 
                               impactClass === 'positive' ? '#00b894' : 
                               impactClass === 'negative' ? '#e17055' : '#fdcb6e';
            
            weatherHTML += `
                <div style="
                    background: rgba(255, 255, 255, 0.2); 
                    padding: 12px; 
                    border-radius: 8px; 
                    text-align: center;
                    border-left: 4px solid ${borderColor};
                    transition: all 0.3s ease;
                " onmouseover="this.style.transform='translateY(-2px)'; this.style.background='rgba(255, 255, 255, 0.25)'" 
                   onmouseout="this.style.transform='translateY(0)'; this.style.background='rgba(255, 255, 255, 0.2)'">
                    <div style="font-weight: bold;">Den ${day.day}</div>
                    <div style="font-size: 0.8em; margin: 3px 0;">${day.date.toLocaleDateString('cs-CZ', { weekday: 'short', day: 'numeric', month: 'numeric' })}</div>
                    <div>üå°Ô∏è ${Math.round(day.temp)}¬∞C</div>
                    <div>üíß ${day.rain.toFixed(1)} mm</div>
                    <div style="font-size: 0.8em; margin-top: 5px;">${day.description}</div>
                    ${day.qualityRisk ? '<div style="color: #e74c3c; font-size: 0.7em; font-weight: bold; margin-top: 3px;">‚ö†Ô∏è Riziko kvality</div>' : ''}
                </div>
            `;
        });
        weatherHTML += '</div>';
    }
    
    weatherDisplay.innerHTML = weatherHTML;
    
    // Zobrazit varov√°n√≠ kvality pokud je pot≈ôeba
    if (weatherSummary.qualityRisk && environment !== 'indoor' && qualityWarning) {
        const tempThreshold = document.getElementById('qualityTempThreshold')?.value || 28;
        qualityWarning.style.display = 'block';
        qualityWarning.innerHTML = `
            ‚ö†Ô∏è <strong>Varov√°n√≠ kvality:</strong> Oƒçek√°van√© vysok√© teploty (nad ${tempThreshold}¬∞C) 
            mohou zp≈Øsobit rozt√©k√°n√≠ ƒçokol√°dov√Ωch polev! Doporuƒçujeme chladic√≠ boxy.
        `;
    } else if (qualityWarning) {
        qualityWarning.style.display = 'none';
    }
}

function getWeatherImpactTextImproved(impact) {
    if (impact > 1.15) {
        return { text: '‚òÄÔ∏è Vynikaj√≠c√≠ podm√≠nky (+15% a≈æ +30%)', color: '#00b894' };
    } else if (impact > 1.05) {
        return { text: 'üå§Ô∏è Dobr√© podm√≠nky (+5% a≈æ +15%)', color: '#00b894' };
    } else if (impact > 0.95) {
        return { text: '‚õÖ Neutr√°ln√≠ podm√≠nky (¬±5%)', color: '#74b9ff' };
    } else if (impact > 0.8) {
        return { text: 'üåßÔ∏è M√©nƒõ p≈ô√≠zniv√© (-5% a≈æ -20%)', color: '#fdcb6e' };
    } else {
        return { text: '‚õàÔ∏è Nep≈ô√≠zniv√© podm√≠nky (-20% a≈æ -40%)', color: '#e17055' };
    }
}

// === FIN√ÅLN√ç OPRAVY - FUNKCE PRO PARSOV√ÅN√ç UD√ÅLOST√ç ===
function parseEventFromRowImproved(eventObject, headers) {
    // Funkce pro hled√°n√≠ pole podle mo≈æn√Ωch n√°zv≈Ø
    const getField = (possibleNames) => {
        for (let name of possibleNames) {
            for (let header of headers) {
                if (header.includes(name.toLowerCase())) {
                    return eventObject[header] || '';
                }
            }
        }
        return '';
    };

    // Parsov√°n√≠ datum≈Ø
    const dateFrom = getField(['datum od', 'date from', 'start date', 'zaƒç√°tek', 'datum']);
    const dateTo = getField(['datum do', 'date to', 'end date', 'konec']);
    
    const startDate = parseCSVDateImproved(dateFrom);
    const endDate = parseCSVDateImproved(dateTo) || startDate;
    
    let duration = 1;
    if (startDate && endDate) {
        const timeDiff = endDate.getTime() - startDate.getTime();
        duration = Math.max(1, Math.ceil(timeDiff / (1000 * 3600 * 24)) + 1);
    }

    const processedEvent = {
        // Z√°kladn√≠ informace
        eventName: getField(['n√°zev akce', 'event name', 'n√°zev', 'akce']),
        location: getField(['lokalita', 'location', 'mƒõsto', 'city', 'm√≠sto']),
        category: getField(['kategorie', 'category', 'typ', 'type']),
        eventType: getField(['typ akce', 'event type', 'druh']),
        confirmed: getField(['potvrzeno', 'confirmed', 'potvrzen√≠', 'status']),
        
        // Datumy
        startDate: startDate,
        endDate: endDate,
        eventDate: startDate,
        date: startDate ? startDate.toISOString().split('T')[0] : '',
        duration: duration,
        
        // ƒå√≠seln√© √∫daje
        actualSales: parseIntSafe(getField(['skuteƒçn√Ω prodej', 'actual sales', 'prod√°no', 'sold', 'prodej'])),
        estimatedSales: parseIntSafe(getField(['odhad prodeje', 'estimated sales', 'odhad', 'predikce', 'estimate'])),
        attendance: parseIntSafe(getField(['n√°v≈°tƒõvnost', 'attendance', 'n√°v≈°tƒõvn√≠ci', 'visitors'])),
        expectedVisitors: parseIntSafe(getField(['oƒçek√°van√° n√°v≈°tƒõvnost', 'expected visitors', 'expected'])),
        
        // Finanƒçn√≠ √∫daje
        rentalCost: parseFloatSafe(getField(['cena n√°jmu', 'rental cost', 'n√°jem', 'rent'])),
        transportCost: parseFloatSafe(getField(['n√°klady na cestu', 'transport cost', 'doprava', 'transport'])),
        otherCosts: parseFloatSafe(getField(['ostatn√≠ n√°klady', 'other costs', 'ostatn√≠', 'other'])),
        
        // Dal≈°√≠ √∫daje
        rating: parseIntSafe(getField(['hodnocen√≠', 'rating', 'hodnocen√≠ akce', 'stars'])),
        competition: parseIntSafe(getField(['konkurence', 'competition', 'competitors']) || '1'),
        weather: getField(['poƒças√≠', 'weather', 'poƒças√≠ bƒõhem akce']),
        environment: getField(['prost≈ôed√≠', 'environment', 'indoor', 'outdoor']),
        
        // Metadata
        notes: getField(['pozn√°mka', 'notes', 'poznamky', 'comments']),
        responsiblePerson: getField(['odpovƒõdn√° osoba', 'responsible', 'zodpovƒõdn√Ω']),
        
        // Syst√©mov√© √∫daje
        id: generateEventId(
            getField(['n√°zev akce', 'event name']) || 'event',
            dateFrom || new Date().toISOString(),
            getField(['lokalita', 'location']) || 'unknown'
        ),
        
        source: 'sheet',
        color: eventColors[Math.floor(Math.random() * eventColors.length)],
        rawData: eventObject,
        importedAt: new Date().toISOString()
    };

    return processedEvent;
}

// Vylep≈°en√° funkce pro parsov√°n√≠ CSV datum≈Ø
function parseCSVDateImproved(dateStr) {
    if (!dateStr || dateStr.trim() === '') return null;
    
    try {
        const cleanStr = dateStr.trim();
        
        // R≈Øzn√© form√°ty datum≈Ø
        const formats = [
            /^(\d{1,2})\.(\d{1,2})\.(\d{4})$/, // DD.MM.YYYY
            /^(\d{1,2})\/(\d{1,2})\/(\d{4})$/, // DD/MM/YYYY  
            /^(\d{4})-(\d{1,2})-(\d{1,2})$/, // YYYY-MM-DD
            /^(\d{1,2})-(\d{1,2})-(\d{4})$/, // DD-MM-YYYY
            /^(\d{1,2})\s+(\d{1,2})\s+(\d{4})$/, // DD MM YYYY
        ];
        
        for (const format of formats) {
            const match = cleanStr.match(format);
            if (match) {
                let day, month, year;
                
                if (format === formats[2]) { // YYYY-MM-DD
                    [, year, month, day] = match;
                } else { // DD.MM.YYYY, DD/MM/YYYY, DD-MM-YYYY, DD MM YYYY
                    [, day, month, year] = match;
                }
                
                const date = new Date(parseInt(year), parseInt(month) - 1, parseInt(day));
                
                // Validace
                if (date.getFullYear() == year && 
                    date.getMonth() == month - 1 && 
                    date.getDate() == day &&
                    year >= 2020 && year <= 2030) {
                    return date;
                }
            }
        }
        
        // Excel serial date format
        const serialDate = parseFloat(cleanStr);
        if (!isNaN(serialDate) && serialDate > 44000 && serialDate < 50000) {
            const excelEpoch = new Date(1900, 0, 1);
            const date = new Date(excelEpoch.getTime() + (serialDate - 2) * 24 * 60 * 60 * 1000);
            return date;
        }
        
        // Pokus o standardn√≠ parsov√°n√≠
        const isoDate = new Date(cleanStr);
        if (!isNaN(isoDate.getTime()) && isoDate.getFullYear() >= 2020 && isoDate.getFullYear() <= 2030) {
            return isoDate;
        }
        
        console.warn('Could not parse date:', cleanStr);
        return null;
        
    } catch (error) {
        console.warn('Date parsing error:', error, 'for date string:', dateStr);
        return null;
    }
}

// === FIN√ÅLN√ç OPRAVY - CHYBƒöJ√çC√ç FUNKCE ===
// Nahradit p≈Øvodn√≠ displayWeatherResults
window.displayWeatherResults = displayWeatherResultsImproved;

// P≈ôidat chybƒõj√≠c√≠ funkci pro enhanced location validation
if (typeof enhancedLocationValidation === 'undefined') {
    window.enhancedLocationValidation = enhancedLocationValidationImproved;
}

// Opravit updateAutocompleteData
if (typeof updateAutocompleteData === 'undefined') {
    window.updateAutocompleteData = updateAutocompleteDataImproved;
}

console.log('‚úÖ Fin√°ln√≠ opravy aplikov√°ny - v≈°echny funkcionality opraveny');

// =============================================================================
// GOOGLE MAPS INTEGRATION
// =============================================================================

function initializeGoogleMaps() {
    if (googleMapsLoaded) return;
    
    const script = document.createElement('script');
    script.src = `https://maps.googleapis.com/maps/api/js?key=${GOOGLE_MAPS_API_KEY}&libraries=places&language=cs&region=CZ`;
    script.async = true;
    script.defer = true;
    script.onload = () => {
        googleMapsLoaded = true;
        console.log('‚úÖ Google Maps API loaded successfully');
    };
    script.onerror = () => {
        console.error('‚ùå Failed to load Google Maps API');
        showMessage('Chyba naƒç√≠t√°n√≠ Google Maps API', 'error');
    };
    document.head.appendChild(script);
}

async function updateTransportCost(lat, lon) {
    try {
        const distance = calculateDistance(PRAGUE_COORDS.lat, PRAGUE_COORDS.lon, lat, lon);
        const transportRate = parseFloat(document.getElementById('defaultTransportRate')?.value) || 10;
        
        const baseCost = 200;
        const distanceCost = distance * 2 * transportRate;
        const totalCost = Math.round(baseCost + distanceCost);
        const finalCost = Math.min(totalCost, 5000);
        
        const transportInput = document.getElementById('transportCost');
        if (transportInput) {
            transportInput.value = finalCost;
        }
        
        console.log(`üöö Transport cost calculated: ${distance.toFixed(1)}km = ${finalCost} Kƒç`);
        
    } catch (error) {
        console.error('Transport cost calculation error:', error);
    }
}

function calculateDistance(lat1, lon1, lat2, lon2) {
    const R = 6371; // Earth's radius in kilometers
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
              Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
              Math.sin(dLon/2) * Math.sin(dLon/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c;
}

// =============================================================================
// LOCATION SERVICES AND GEOCODING
// =============================================================================

async function getLocationCoordinates(locationName) {
    try {
        const geoUrl = `https://api.openweathermap.org/geo/1.0/direct?q=${encodeURIComponent(locationName)},CZ&limit=1&appid=${WEATHER_API_KEY}`;
        const response = await fetch(geoUrl);
        const data = await response.json();
        
        if (data && data.length > 0) {
            return {
                lat: data[0].lat,
                lon: data[0].lon,
                name: data[0].name
            };
        }
        
        throw new Error('Location not found');
    } catch (error) {
        console.error('Geocoding error:', error);
        return null;
    }
}

function validateLocation(locationName) {
    const czechCities = [
        'Praha', 'Brno', 'Ostrava', 'Plze≈à', 'Liberec', 'Olomouc', '√öst√≠ nad Labem',
        'ƒåesk√© Budƒõjovice', 'Hradec Kr√°lov√©', 'Pardubice', 'Zl√≠n', 'Hav√≠≈ôov',
        'Kladno', 'Most', 'Opava', 'Fr√Ωdek-M√≠stek', 'Karvin√°', 'Jihlava',
        'Teplice', 'Dƒõƒç√≠n', 'Karlovy Vary', 'Jablonec nad Nisou', 'Mlad√° Boleslav',
        'Prostƒõjov', 'P≈ôerov', 'ƒåesk√° L√≠pa', 'T≈ôinec', 'T√°bor', 'Znojmo',
        'P≈ô√≠bram', 'Cheb', 'Trutnov', 'Orlov√°', 'Litv√≠nov', 'Brand√Ωs nad Labem-Star√° Boleslav'
    ];
    
    const normalized = locationName.toLowerCase().trim();
    
    for (const city of czechCities) {
        if (city.toLowerCase().includes(normalized) || normalized.includes(city.toLowerCase())) {
            return true;
        }
    }
    
    return false;
}

// Enhanced location input handler with better validation
function enhancedLocationValidation() {
    const locationInput = document.getElementById('eventLocation');
    if (!locationInput) return;
    
    const location = locationInput.value.trim();
    const formGroup = locationInput.parentElement;
    
    // Remove existing validation classes
    formGroup.classList.remove('has-error', 'has-success', 'has-warning');
    
    if (location.length < 2) return;
    
    if (validateLocation(location)) {
        formGroup.classList.add('has-success');
        loadWeather(); // Auto-load weather for valid Czech cities
    } else if (location.length > 3) {
        formGroup.classList.add('has-warning');
        // Still try to load weather for international locations
        setTimeout(() => loadWeather(), 500);
    }
}

// =============================================================================
// WEATHER UTILITIES AND HELPERS
// =============================================================================

function getWeatherIcon(iconCode) {
    const iconMap = {
        '01d': '‚òÄÔ∏è', '01n': 'üåô',
        '02d': '‚õÖ', '02n': '‚õÖ',
        '03d': '‚òÅÔ∏è', '03n': '‚òÅÔ∏è',
        '04d': '‚òÅÔ∏è', '04n': '‚òÅÔ∏è',
        '09d': 'üåßÔ∏è', '09n': 'üåßÔ∏è',
        '10d': 'üå¶Ô∏è', '10n': 'üå¶Ô∏è',
        '11d': '‚õàÔ∏è', '11n': '‚õàÔ∏è',
        '13d': '‚ùÑÔ∏è', '13n': '‚ùÑÔ∏è',
        '50d': 'üå´Ô∏è', '50n': 'üå´Ô∏è'
    };
    
    return iconMap[iconCode] || 'üå§Ô∏è';
}

function getSeasonalWeatherAdvice(month, weatherSummary) {
    const advice = [];
    
    if (month >= 6 && month <= 8) { // Summer
        if (weatherSummary.maxTemp > 28) {
            advice.push('üßä Doporuƒçujeme chladic√≠ boxy pro udr≈æen√≠ kvality');
        }
        if (weatherSummary.totalRain > 10) {
            advice.push('‚òÇÔ∏è P≈ô√≠prava na de≈°tiv√© poƒças√≠ - stany/p≈ô√≠st≈ôe≈°ky');
        }
    } else if (month >= 12 || month <= 2) { // Winter
        advice.push('üß• Tepl√© obleƒçen√≠ pro brig√°dn√≠ky');
        if (weatherSummary.avgTemp < 5) {
            advice.push('‚ùÑÔ∏è Pozor na zmrznut√≠ tekutin');
        }
    }
    
    return advice;
}

function formatWeatherForExport(weatherData) {
    if (!weatherData) return 'Bez dat o poƒças√≠';
    
    return `Teploty: ${weatherData.minTemp?.toFixed(1)}¬∞C - ${weatherData.maxTemp?.toFixed(1)}¬∞C, ` +
           `Sr√°≈æky: ${weatherData.totalRain?.toFixed(1)}mm, ` +
           `Dopad: ${((weatherData.environmentImpact - 1) * 100).toFixed(0)}%`;
}

// Auto-refresh weather data for events in the next 7 days
function scheduleWeatherRefresh() {
    setInterval(async () => {
        const upcomingEvents = localSavedEvents.filter(event => {
            const eventDate = new Date(event.date);
            const today = new Date();
            const diffDays = (eventDate - today) / (1000 * 60 * 60 * 24);
            return diffDays >= 0 && diffDays <= 7;
        });
        
        if (upcomingEvents.length > 0) {
            console.log(`üîÑ Refreshing weather for ${upcomingEvents.length} upcoming events`);
            // Refresh weather data for upcoming events
            for (const event of upcomingEvents.slice(0, 3)) { // Limit to 3 to avoid API rate limits
                try {
                    if (event.location) {
                        // Refresh weather data silently
                        await getLocationCoordinates(event.location);
                    }
                } catch (error) {
                    console.warn('Weather refresh failed for event:', event.eventName);
                }
            }
        }
    }, 30 * 60 * 1000); // Every 30 minutes
}

console.log('üìù ƒå√°st 7 naƒçtena - Weather API a Google Maps integrace');
    // ƒå√ÅST 8: KALEND√Å≈ò A EVENT MANAGEMENT
// P≈ôidejte tuto ƒç√°st za ƒå√°st 7 v <script> tagu

// =============================================================================
// CALENDAR SYSTEM
// =============================================================================

function initializeCalendar() {
    console.log('üìÖ Initializing calendar...');
    updateMonthYearDisplay();
    if (calendarView === 'month') {
        renderCalendar();
    } else {
        renderEventList();
    }
}

function renderCalendar() {
    const year = currentDate.getFullYear();
    const month = currentDate.getMonth();
    const firstDay = new Date(year, month, 1).getDay();
    const daysInMonth = new Date(year, month + 1, 0).getDate();
    
    const calendarGrid = document.getElementById('calendarGrid');
    if (!calendarGrid) return;
    
    // Clear existing content except headers
    const headerCells = Array.from(calendarGrid.children).slice(0, 7);
    calendarGrid.innerHTML = '';
    calendarGrid.style.display = 'grid';
    calendarGrid.style.gridTemplateColumns = 'repeat(7, 1fr)';
    calendarGrid.style.gap = '1px';
    calendarGrid.style.background = '#ddd';
    calendarGrid.style.borderRadius = '8px';
    calendarGrid.style.overflow = 'hidden';
    calendarGrid.style.marginBottom = '20px';
    
    headerCells.forEach(cell => calendarGrid.appendChild(cell));
    
    // Add empty cells for days before month starts
    const startDay = firstDay === 0 ? 6 : firstDay - 1;
    for (let i = 0; i < startDay; i++) {
        const emptyDay = document.createElement('div');
        emptyDay.style.cssText = 'background: #f8f9fa; padding: 10px; min-height: 100px;';
        calendarGrid.appendChild(emptyDay);
    }
    
    // Add days of month
    for (let day = 1; day <= daysInMonth; day++) {
        const dayCell = createDayCell(year, month, day);
        calendarGrid.appendChild(dayCell);
    }
}

function createDayCell(year, month, day) {
    const dayCell = document.createElement('div');
    dayCell.style.cssText = `
        background: white; 
        padding: 8px; 
        min-height: 100px; 
        cursor: pointer; 
        position: relative; 
        border: 1px solid #e9ecef;
        transition: all 0.2s ease;
    `;
    
    // Day number
    const dayNumber = document.createElement('div');
    dayNumber.style.cssText = 'font-weight: bold; margin-bottom: 5px; font-size: 0.9em; color: #2c3e50;';
    dayNumber.textContent = day;
    dayCell.appendChild(dayNumber);
    
    // Check for events on this day
    const dayEvents = getEventsForDay(year, month, day);
    
    // Add events to day cell
    dayEvents.forEach((event, index) => {
        if (index < 3) { // Show max 3 events
            const eventDiv = createEventDiv(event, index);
            dayCell.appendChild(eventDiv);
        }
    });
    
    // Show "more events" indicator
    if (dayEvents.length > 3) {
        const moreDiv = document.createElement('div');
        moreDiv.style.cssText = `
            font-size: 0.7em; 
            color: #7f8c8d; 
            text-align: center; 
            margin-top: 2px;
            cursor: pointer;
            padding: 2px;
            border-radius: 3px;
            background: rgba(52, 152, 219, 0.1);
        `;
        moreDiv.textContent = `+${dayEvents.length - 3} dal≈°√≠`;
        moreDiv.onclick = (e) => {
            e.stopPropagation();
            showDayEventsModal(year, month, day, dayEvents);
        };
        dayCell.appendChild(moreDiv);
    }
    
    // Highlight today
    const today = new Date();
    if (year === today.getFullYear() && month === today.getMonth() && day === today.getDate()) {
        dayCell.style.backgroundColor = '#e3f2fd';
        dayCell.style.border = '2px solid #2196f3';
        dayNumber.style.color = '#1976d2';
        dayNumber.style.fontWeight = 'bold';
    }
    
    // Hover effects
    dayCell.onmouseenter = () => {
        if (!dayCell.style.border.includes('2196f3')) {
            dayCell.style.backgroundColor = '#f8f9fa';
            dayCell.style.transform = 'translateY(-1px)';
            dayCell.style.boxShadow = '0 2px 8px rgba(0,0,0,0.1)';
        }
    };
    
    dayCell.onmouseleave = () => {
        if (!dayCell.style.border.includes('2196f3')) {
            dayCell.style.backgroundColor = 'white';
            dayCell.style.transform = 'translateY(0)';
            dayCell.style.boxShadow = 'none';
        }
    };
    
    // Click handler
    dayCell.onclick = () => {
        if (dayEvents.length === 1) {
            showEventDetails(dayEvents[0].id);
        } else if (dayEvents.length > 1) {
            showDayEventsModal(year, month, day, dayEvents);
        }
    };
    
    return dayCell;
}

function createEventDiv(event, index) {
    const eventDiv = document.createElement('div');
    
    let bgColor = event.color || '#3498db';
    let textColor = 'white';
    
    if (event.financials) {
        if (event.financials.profit > 0) {
            bgColor = '#27ae60';
        } else {
            bgColor = '#e74c3c';
        }
    }
    
    // Check if event is in progress or upcoming
    const eventDate = new Date(event.date || event.eventDate);
    const today = new Date();
    const isPast = eventDate < today;
    
    if (isPast) {
        textColor = 'rgba(255,255,255,0.8)';
        bgColor = adjustColorOpacity(bgColor, 0.7);
    }
    
    eventDiv.style.cssText = `
        font-size: 0.7em; 
        padding: 2px 4px; 
        margin: 1px 0; 
        border-radius: 3px; 
        overflow: hidden; 
        text-overflow: ellipsis; 
        white-space: nowrap;
        background: ${bgColor};
        color: ${textColor};
        cursor: pointer;
        transition: all 0.2s ease;
    `;
    
    let eventText = event.eventName || 'Bez n√°zvu';
    if (event.predictedSales) {
        eventText += ` (${event.predictedSales}ks)`;
    }
    if (event.source === 'sheet') {
        eventText = 'üìä ' + eventText;
    }
    
    eventDiv.textContent = eventText;
    
    // Event hover effects
    eventDiv.onmouseenter = (e) => {
        e.stopPropagation();
        eventDiv.style.transform = 'scale(1.05)';
        eventDiv.style.zIndex = '10';
    };
    
    eventDiv.onmouseleave = (e) => {
        e.stopPropagation();
        eventDiv.style.transform = 'scale(1)';
        eventDiv.style.zIndex = '1';
    };
    
    // Event click handler
    eventDiv.onclick = (e) => {
        e.stopPropagation();
        showEventDetails(event.id);
    };
    
    return eventDiv;
}

function getEventsForDay(year, month, day) {
    const targetDate = new Date(year, month, day);
    const allEvents = [...localSavedEvents, ...plannedEvents, ...historicalData];
    
    return allEvents.filter(event => {
        const eventDate = new Date(event.date || event.eventDate);
        
        // Check if event spans multiple days
        if (event.duration && event.duration > 1) {
            const endDate = new Date(eventDate);
            endDate.setDate(eventDate.getDate() + event.duration - 1);
            return targetDate >= eventDate && targetDate <= endDate;
        }
        
        return eventDate.toDateString() === targetDate.toDateString();
    }).sort((a, b) => {
        // Sort by time if available, otherwise by predicted sales
        const aPriority = a.predictedSales || a.actualSales || 0;
        const bPriority = b.predictedSales || b.actualSales || 0;
        return bPriority - aPriority;
    });
}

function toggleCalendarView() {
    const calendarViewDiv = document.getElementById('calendarView');
    const listViewDiv = document.getElementById('listView');
    const toggleBtn = document.getElementById('viewToggleBtn');
    
    if (calendarView === 'month') {
        calendarView = 'list';
        calendarViewDiv.style.display = 'none';
        listViewDiv.style.display = 'block';
        toggleBtn.textContent = 'üìÖ Kalend√°≈ôov√Ω pohled';
        renderEventList();
    } else {
        calendarView = 'month';
        calendarViewDiv.style.display = 'block';
        listViewDiv.style.display = 'none';
        toggleBtn.textContent = 'üìã Seznam akc√≠';
        renderCalendar();
    }
}

function renderEventList() {
    const eventsList = document.getElementById('eventsList');
    if (!eventsList) return;
    
    const allEvents = [...localSavedEvents, ...plannedEvents, ...historicalData];
    const sortedEvents = allEvents.sort((a, b) => {
        const dateA = new Date(a.date || a.eventDate);
        const dateB = new Date(b.date || b.eventDate);
        return dateB - dateA; // Newest first
    });
    
    if (sortedEvents.length === 0) {
        eventsList.innerHTML = `
            <div style="text-align: center; padding: 40px; color: #7f8c8d;">
                <div style="font-size: 3em; margin-bottom: 15px;">üìÖ</div>
                <h3>≈Ω√°dn√© akce v kalend√°≈ôi</h3>
                <p>Zaƒçnƒõte vytvo≈ôen√≠m nov√© predikce v z√°lo≈æce AI Predikce</p>
            </div>
        `;
        return;
    }
    
    let eventsHTML = '';
    const today = new Date();
    
    sortedEvents.forEach(event => {
        const eventDate = new Date(event.date || event.eventDate);
        const isPast = eventDate < today;
        const isSheetEvent = event.source === 'sheet';
        
        let statusBadges = '';
        if (isSheetEvent) {
            statusBadges += '<span class="event-status-badge">ZE SHEETU</span>';
        }
        if (event.isManualOverride) {
            statusBadges += '<span class="event-status-badge manual-override">UPRAVENO</span>';
        }
        if (isPast && event.actualSales) {
            statusBadges += '<span class="event-status-badge completed">DOKONƒåENO</span>';
        }
        
        const profitInfo = event.financials ? 
            `<div style="margin-top: 8px; font-size: 0.9em;">
                üí∞ Zisk: <span style="color: ${event.financials.profit >= 0 ? '#27ae60' : '#e74c3c'}">${Math.round(event.financials.profit || 0).toLocaleString('cs-CZ')} Kƒç</span>
            </div>` : '';
        
        const salesInfo = event.actualSales ? 
            `üìä Skuteƒçn√Ω prodej: ${event.actualSales.toLocaleString('cs-CZ')} ks` :
            `üéØ Predikce: ${(event.predictedSales || 0).toLocaleString('cs-CZ')} ks`;
        
        eventsHTML += `
            <div class="event-list-item ${isPast ? 'past' : ''} ${isSheetEvent ? 'sheet-event' : ''}" 
                 onclick="showEventDetails('${event.id}')"
                 style="border-left-color: ${event.financials?.profit >= 0 ? '#27ae60' : '#e74c3c'}">
                <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">
                    <div>
                        <h4 style="margin: 0; color: #2c3e50;">${event.eventName || 'Bez n√°zvu'}${statusBadges}</h4>
                        <div style="color: #7f8c8d; font-size: 0.9em; margin-top: 4px;">
                            üìÖ ${eventDate.toLocaleDateString('cs-CZ', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' })}
                            ${event.duration > 1 ? ` (${event.duration} dn√≠)` : ''}
                        </div>
                        <div style="color: #7f8c8d; font-size: 0.9em;">üìç ${event.location || 'Nezn√°m√° lokalita'}</div>
                    </div>
                    <div style="text-align: right; font-size: 0.9em;">
                        <div>${salesInfo}</div>
                        <div style="margin-top: 4px;">üë• ${(event.expectedVisitors || event.attendance || 0).toLocaleString('cs-CZ')} n√°v≈°tƒõvn√≠k≈Ø</div>
                        ${profitInfo}
                    </div>
                </div>
                <div style="display: flex; justify-content: space-between; align-items: center; font-size: 0.85em; color: #95a5a6;">
                    <span>üé™ ${event.category || event.eventType || 'Ostatn√≠'}</span>
                    ${event.confidence ? `<span>üìä Spolehlivost: ${event.confidence}%</span>` : ''}
                </div>
            </div>
        `;
    });
    
    eventsList.innerHTML = eventsHTML;
}

// =============================================================================
// EVENT DETAILS AND MODAL MANAGEMENT
// =============================================================================

function showEventDetails(eventId) {
    console.log('üìã Showing event details for:', eventId);
    
    let event = localSavedEvents.find(e => e.id === eventId);
    if (!event) event = plannedEvents.find(e => e.id === eventId);
    if (!event) event = historicalData.find(e => e.id === eventId);
    
    if (!event) {
        showMessage('Akce nebyla nalezena', 'error');
        return;
    }
    
    selectedEventId = eventId;
    const modal = document.getElementById('eventModal');
    const content = document.getElementById('eventModalContent');
    
    const eventDate = new Date(event.date || event.eventDate);
    const endDate = new Date(eventDate);
    endDate.setDate(endDate.getDate() + ((event.duration || 1) - 1));
    
    const isSheetEvent = event.source === 'sheet';
    const isPastEvent = eventDate < new Date();
    
    content.innerHTML = createEventDetailsHTML(event, eventDate, endDate, isSheetEvent, isPastEvent);
    
    modal.style.display = 'block';
    document.body.style.overflow = 'hidden';
}

function createEventDetailsHTML(event, eventDate, endDate, isSheetEvent, isPastEvent) {
    let html = `
        <h2 style="color: #2c3e50; margin-bottom: 20px; display: flex; align-items: center; gap: 10px;">
            ${event.eventName || 'Bez n√°zvu'}
            ${isSheetEvent ? '<span style="font-size: 0.6em; background: #f39c12; color: white; padding: 4px 8px; border-radius: 4px;">ZE SHEETU</span>' : ''}
            ${event.isManualOverride ? '<span style="font-size: 0.6em; background: #9b59b6; color: white; padding: 4px 8px; border-radius: 4px;">UPRAVENO</span>' : ''}
        </h2>
        
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin-bottom: 20px;">
            <div>
                <h4 style="color: #34495e; margin-bottom: 15px; border-bottom: 2px solid #3498db; padding-bottom: 5px;">üìã Z√°kladn√≠ informace</h4>
                <div style="line-height: 1.8; color: #2c3e50;">
                    <div><strong>üìÖ Datum:</strong> ${eventDate.toLocaleDateString('cs-CZ', { 
                        weekday: 'long', 
                        year: 'numeric', 
                        month: 'long', 
                        day: 'numeric' 
                    })}</div>
                    ${event.duration > 1 ? `<div><strong>üìÖ Konec:</strong> ${endDate.toLocaleDateString('cs-CZ')}</div>` : ''}
                    <div><strong>üìç M√≠sto:</strong> ${event.location || 'Nezn√°m√° lokalita'}</div>
                    <div><strong>üé™ Typ:</strong> ${event.category || event.eventType || 'Ostatn√≠'}</div>
                    <div><strong>üë• N√°v≈°tƒõvnost:</strong> ${(event.expectedVisitors || event.attendance || 0).toLocaleString('cs-CZ')}</div>
                    <div><strong>‚è±Ô∏è D√©lka:</strong> ${event.duration || 1} ${(event.duration || 1) === 1 ? 'den' : 'dn√≠'}</div>
                    ${event.businessModel ? `<div><strong>üíº Model:</strong> ${getBusinessModelDisplayName(event.businessModel)}</div>` : ''}
                    ${event.environment ? `<div><strong>üè¢ Prost≈ôed√≠:</strong> ${event.environment === 'outdoor' ? 'Venkovn√≠' : event.environment === 'indoor' ? 'Vnit≈ôn√≠' : 'Sm√≠≈°en√©'}</div>` : ''}
                </div>
            </div>
            
            <div>
                <h4 style="color: #34495e; margin-bottom: 15px; border-bottom: 2px solid #27ae60; padding-bottom: 5px;">üìä V√Ωkonnost</h4>
                <div style="line-height: 1.8;">
        `;
        
        if (isPastEvent && event.actualSales) {
            html += `
                        <div><strong>‚úÖ Skuteƒçn√Ω prodej:</strong> ${event.actualSales.toLocaleString('cs-CZ')} ks</div>
                        ${event.estimatedSales ? `<div><strong>üéØ P≈Øvodn√≠ odhad:</strong> ${event.estimatedSales.toLocaleString('cs-CZ')} ks</div>` : ''}
                        ${event.estimatedSales ? `<div><strong>üìà P≈ôesnost predikce:</strong> ${Math.round((event.actualSales / event.estimatedSales) * 100)}%</div>` : ''}
                        ${event.rating ? `<div><strong>‚≠ê Hodnocen√≠ akce:</strong> ${event.rating}/5</div>` : ''}
                        <div><strong>üìä Konverzn√≠ pomƒõr:</strong> ${((event.actualSales / (event.attendance || event.expectedVisitors || 1)) * 100).toFixed(2)}%</div>
            `;
        } else if (event.predictedSales) {
            html += `
                        <div><strong>üéØ Predikce prodeje:</strong> ${event.predictedSales.toLocaleString('cs-CZ')} ks</div>
                        ${event.confidence ? `<div><strong>üìä Spolehlivost:</strong> ${event.confidence}%</div>` : ''}
                        <div><strong>üìà Oƒçek√°van√Ω konverzn√≠ pomƒõr:</strong> ${((event.predictedSales / (event.expectedVisitors || 1)) * 100).toFixed(2)}%</div>
                        ${event.isManualOverride ? `<div style="color: #9b59b6;"><strong>‚úèÔ∏è Ruƒçnƒõ upraveno:</strong> ${event.overrideReason ? getOverrideReasonText(event.overrideReason) : 'Ano'}</div>` : ''}
            `;
        } else {
            html += `<div style="color: #7f8c8d; font-style: italic;">≈Ω√°dn√© predikƒçn√≠ √∫daje nejsou k dispozici</div>`;
        }
        
        html += `
                </div>
            </div>
        </div>
    `;
    
    // Financial Analysis Section
    if (event.financials) {
        html += createFinancialAnalysisSection(event);
    }
    
    // Weather Section
    if (event.weather) {
        html += createWeatherSection(event);
    }
    
    // Notes and Additional Info
    if (event.notes || event.responsiblePerson || event.competition) {
        html += `
            <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 15px 0;">
                <h4 style="color: #34495e; margin-bottom: 10px;">üìù Dodateƒçn√© informace</h4>
                ${event.notes ? `<div style="margin-bottom: 8px;"><strong>Pozn√°mky:</strong> ${event.notes}</div>` : ''}
                ${event.responsiblePerson ? `<div style="margin-bottom: 8px;"><strong>Odpovƒõdn√° osoba:</strong> ${event.responsiblePerson}</div>` : ''}
                ${event.competition ? `<div style="margin-bottom: 8px;"><strong>Konkurence:</strong> ${event.competition}</div>` : ''}
                ${event.transportCost ? `<div style="margin-bottom: 8px;"><strong>N√°klady na dopravu:</strong> ${event.transportCost.toLocaleString('cs-CZ')} Kƒç</div>` : ''}
            </div>
        `;
    }
    
    // Metadata
    html += `
        <div style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #e9ecef; font-size: 0.9em; color: #7f8c8d;">
            <div style="display: flex; justify-content: space-between; flex-wrap: wrap; gap: 10px;">
                <div>
                    ${isSheetEvent ? 'Naƒçteno ze Sheetu' : 'Lok√°ln√≠ predikce'}
                    ${event.savedAt ? ` | Ulo≈æeno: ${new Date(event.savedAt).toLocaleString('cs-CZ')}` : ''}
                </div>
                <div>
                    ID: ${event.id}
                </div>
            </div>
        </div>
    `;
    
    return html;
}

function createFinancialAnalysisSection(event) {
    const financials = event.financials;
    const businessModel = event.businessModel || 'owner';
    
    let html = `
        <div style="background: linear-gradient(135deg, #74b9ff, #0984e3); color: white; padding: 20px; border-radius: 12px; margin: 20px 0;">
            <h4 style="margin: 0 0 20px 0;">üí∞ Finanƒçn√≠ anal√Ωza (${getBusinessModelDisplayName(businessModel)})</h4>
            
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px;">
                <div style="background: rgba(255, 255, 255, 0.15); padding: 15px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 1.8em; font-weight: bold;">${Math.round(financials.revenue || 0).toLocaleString('cs-CZ')} Kƒç</div>
                    <div style="font-size: 0.9em; opacity: 0.9;">Celkov√Ω obrat</div>
                </div>
                <div style="background: rgba(255, 255, 255, 0.15); padding: 15px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 1.8em; font-weight: bold;">${Math.round(financials.totalCosts || 0).toLocaleString('cs-CZ')} Kƒç</div>
                    <div style="font-size: 0.9em; opacity: 0.9;">Celkov√© n√°klady</div>
                </div>
                <div style="background: rgba(255, 255, 255, 0.15); padding: 15px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 1.8em; font-weight: bold; color: ${financials.profit >= 0 ? '#00b894' : '#e17055'};">
                        ${Math.round(financials.profit || 0).toLocaleString('cs-CZ')} Kƒç
                    </div>
                    <div style="font-size: 0.9em; opacity: 0.9;">ƒåist√Ω zisk</div>
                </div>
                <div style="background: rgba(255, 255, 255, 0.15); padding: 15px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 1.8em; font-weight: bold;">${financials.margin ? financials.margin.toFixed(1) : '0'}%</div>
                    <div style="font-size: 0.9em; opacity: 0.9;">Ziskov√° mar≈æe</div>
                </div>
            </div>
            
            <div style="background: rgba(255, 255, 255, 0.1); padding: 15px; border-radius: 8px;">
                <h5 style="margin: 0 0 15px 0;">üìä Rozpis n√°klad≈Ø</h5>
                <div style="display: grid; gap: 8px; font-size: 0.95em;">
    `;
    
    if (financials.costBreakdown) {
        Object.entries(financials.costBreakdown).forEach(([category, cost]) => {
            html += `<div style="display: flex; justify-content: space-between;">
                <span>${getCategoryIcon(category)} ${category}:</span>
                <span>${Math.round(cost).toLocaleString('cs-CZ')} Kƒç</span>
            </div>`;
        });
    }
    
    if (businessModel === 'franchisee' && financials.yourProfit) {
        html += `
                    <div style="border-top: 1px solid rgba(255,255,255,0.3); padding-top: 10px; margin-top: 10px;">
                        <div style="display: flex; justify-content: space-between; font-weight: bold; color: #00b894;">
                            <span>üíé V√°≈° ƒçist√Ω zisk:</span>
                            <span>${Math.round(financials.yourProfit).toLocaleString('cs-CZ')} Kƒç</span>
                        </div>
                    </div>
        `;
    }
    
    html += `
                    <div style="border-top: 1px solid rgba(255,255,255,0.3); padding-top: 10px; margin-top: 10px;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span>üìà Break-even bod:</span>
                            <span>${financials.breakEvenUnits || 0} ks</span>
                        </div>
                        ${financials.profitPerDonut ? `
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 5px;">
                            <span>üç© Zisk na donut:</span>
                            <span>${financials.profitPerDonut.toFixed(1)} Kƒç</span>
                        </div>
                        ` : ''}
                    </div>
                </div>
            </div>
        </div>
    `;
    
    return html;
}

function createWeatherSection(event) {
    const weather = event.weather;
    
    let html = `
        <div style="background: linear-gradient(135deg, #fd79a8, #e84393); color: white; padding: 20px; border-radius: 12px; margin: 20px 0;">
            <h4 style="margin: 0 0 15px 0;">üå§Ô∏è Poƒças√≠ bƒõhem akce</h4>
    `;
    
    if (weather.dayDetails && weather.dayDetails.length > 0) {
        html += `
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px; margin-bottom: 15px;">
        `;
        
        weather.dayDetails.forEach(day => {
            const qualityRisk = day.qualityRisk ? 'border: 2px solid #e74c3c;' : '';
            html += `
                <div style="background: rgba(255, 255, 255, 0.15); padding: 12px; border-radius: 8px; text-align: center; ${qualityRisk}">
                    <div style="font-weight: bold;">Den ${day.day}</div>
                    <div style="font-size: 0.8em; margin: 3px 0;">${day.date.toLocaleDateString('cs-CZ', { weekday: 'short', day: 'numeric', month: 'numeric' })}</div>
                    <div>üå°Ô∏è ${Math.round(day.temp)}¬∞C</div>
                    <div>üíß ${day.rain.toFixed(1)} mm</div>
                    <div style="font-size: 0.8em; margin-top: 5px;">${day.description}</div>
                    ${day.qualityRisk ? '<div style="color: #e74c3c; font-size: 0.7em; font-weight: bold;">‚ö†Ô∏è Riziko</div>' : ''}
                </div>
            `;
        });
        
        html += '</div>';
        
        if (weather.qualityRisk) {
            html += `
                <div style="background: rgba(231, 76, 60, 0.2); border: 1px solid #e74c3c; padding: 10px; border-radius: 6px; margin-top: 15px;">
                    ‚ö†Ô∏è <strong>Varov√°n√≠ kvality:</strong> Vysok√© teploty mohou zp≈Øsobit rozt√©k√°n√≠ ƒçokol√°dov√Ωch polev!
                </div>
            `;
        }
    } else if (weather.avgTemp !== undefined) {
        html += `
            <div style="background: rgba(255, 255, 255, 0.15); padding: 15px; border-radius: 8px;">
                <div>üå°Ô∏è <strong>Pr≈Ømƒõrn√° teplota:</strong> ${weather.avgTemp.toFixed(1)}¬∞C</div>
                <div>üíß <strong>Celkov√© sr√°≈æky:</strong> ${weather.totalRain.toFixed(1)} mm</div>
                ${weather.environmentImpact ? `<div>üìä <strong>Dopad na prodej:</strong> ${((weather.environmentImpact - 1) * 100).toFixed(0)}%</div>` : ''}
            </div>
        `;
    }
    
    html += '</div>';
    return html;
}

function getBusinessModelDisplayName(model) {
    const names = {
        'owner': 'Majitel (2 brig√°dn√≠ci)',
        'employee': 'Zamƒõstnanec (1 brig√°dn√≠k + pod√≠l)',
        'franchisee': 'Fran≈°√≠zant'
    };
    return names[model] || model;
}

function getOverrideReasonText(reason) {
    const reasons = {
        'experience': 'Osobn√≠ zku≈°enost',
        'local_knowledge': 'M√≠stn√≠ znalost',
        'organizer_info': 'Info od organiz√°tora',
        'weather_concern': 'Obavy z poƒças√≠',
        'competition': 'Konkurence',
        'other': 'Jin√Ω d≈Øvod'
    };
    return reasons[reason] || reason;
}

function showDayEventsModal(year, month, day, events) {
    const date = new Date(year, month, day);
    const dateStr = date.toLocaleDateString('cs-CZ', { 
        weekday: 'long', 
        year: 'numeric', 
        month: 'long', 
        day: 'numeric' 
    });
    
    let eventsHTML = `<h3>üìÖ Akce pro ${dateStr}</h3><div style="margin-top: 20px;">`;
    
    events.forEach(event => {
        const profitColor = event.financials?.profit >= 0 ? '#27ae60' : '#e74c3c';
        eventsHTML += `
            <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 10px 0; cursor: pointer; border-left: 4px solid ${profitColor};" 
                 onclick="closeEventModal(); showEventDetails('${event.id}');">
                <h4 style="margin: 0 0 8px 0; color: #2c3e50;">${event.eventName || 'Bez n√°zvu'}</h4>
                <div style="color: #7f8c8d; font-size: 0.9em;">
                    üìç ${event.location || 'Nezn√°m√° lokalita'} | 
                    üé™ ${event.category || event.eventType || 'Ostatn√≠'} | 
                    üéØ ${(event.predictedSales || event.actualSales || 0).toLocaleString('cs-CZ')} ks
                </div>
                ${event.financials ? `<div style="color: ${profitColor}; font-weight: bold; margin-top: 5px;">üí∞ ${Math.round(event.financials.profit).toLocaleString('cs-CZ')} Kƒç</div>` : ''}
            </div>
        `;
    });
    
    eventsHTML += '</div>';
    
    const modal = document.getElementById('eventModal');
    const content = document.getElementById('eventModalContent');
    content.innerHTML = eventsHTML;
    modal.style.display = 'block';
    document.body.style.overflow = 'hidden';
}

function closeEventModal() {
    const modal = document.getElementById('eventModal');
    modal.style.display = 'none';
    document.body.style.overflow = 'auto';
    selectedEventId = null;
}

function deleteEvent() {
    if (!selectedEventId) return;
    
    const event = localSavedEvents.find(e => e.id === selectedEventId) || 
                 plannedEvents.find(e => e.id === selectedEventId);
    
    if (event && event.source === 'sheet') {
        showMessage('Nelze smazat akci ze Sheetu', 'error');
        return;
    }
    
    if (confirm('Opravdu chcete smazat tuto akci z kalend√°≈ôe?')) {
        localSavedEvents = localSavedEvents.filter(e => e.id !== selectedEventId);
        localStorage.setItem('donulandEvents', JSON.stringify(localSavedEvents));
        
        closeEventModal();
        
        if (calendarView === 'month') {
            renderCalendar();
        } else {
            renderEventList();
        }
        
        const weeklyTab = document.getElementById('weekly');
        if (weeklyTab && weeklyTab.classList.contains('active')) {
            calculateWeeklyPlan();
        }
        
        showMessage('Akce byla smaz√°na z kalend√°≈ôe', 'success');
    }
}

function editEvent() {
    if (!selectedEventId) return;
    
    const event = localSavedEvents.find(e => e.id === selectedEventId);
    
    if (!event) {
        showMessage('Lze upravovat pouze lok√°ln√≠ predikce', 'error');
        return;
    }
    
    // Fill form with event data
    document.getElementById('eventType').value = event.eventType || '';
    document.getElementById('eventName').value = event.eventName || '';
    document.getElementById('eventLocation').value = event.location || '';
    document.getElementById('eventDate').value = event.date || '';
    document.getElementById('eventDuration').value = event.duration || 1;
    document.getElementById('expectedVisitors').value = event.expectedVisitors || 0;
    document.getElementById('eventEnvironment').value = event.environment || 'outdoor';
    
    if (event.businessModel) {
        document.querySelector(`input[name="businessModel"][value="${event.businessModel}"]`).checked = true;
        updateBusinessModelInfo();
    }
    
    closeEventModal();
    showTab('prediction', { target: document.querySelector('.nav-tab') });
    showMessage('Akce byla naƒçtena do formul√°≈ôe pro √∫pravu', 'info');
}

// =============================================================================
// CALENDAR UTILITIES AND HELPERS
// =============================================================================

function getEventsInDateRange(startDate, endDate) {
    const allEvents = [...localSavedEvents, ...plannedEvents, ...historicalData];
    
    return allEvents.filter(event => {
        const eventDate = new Date(event.date || event.eventDate);
        return eventDate >= startDate && eventDate <= endDate;
    });
}

function getUpcomingEvents(days = 7) {
    const today = new Date();
    const futureDate = new Date();
    futureDate.setDate(today.getDate() + days);
    
    return getEventsInDateRange(today, futureDate);
}

function getPastEvents(days = 30) {
    const today = new Date();
    const pastDate = new Date();
    pastDate.setDate(today.getDate() - days);
    
    return getEventsInDateRange(pastDate, today).filter(event => {
        const eventDate = new Date(event.date || event.eventDate);
        return eventDate < today;
    });
}

function getEventsByMonth(year, month) {
    const startDate = new Date(year, month, 1);
    const endDate = new Date(year, month + 1, 0);
    
    return getEventsInDateRange(startDate, endDate);
}

function calculateMonthlyStats(year, month) {
    const events = getEventsByMonth(year, month);
    const stats = {
        totalEvents: events.length,
        totalSales: 0,
        totalProfit: 0,
        averageProfit: 0,
        profitableEvents: 0
    };
    
    events.forEach(event => {
        const sales = event.actualSales || event.predictedSales || 0;
        const profit = event.financials?.profit || 0;
        
        stats.totalSales += sales;
        stats.totalProfit += profit;
        
        if (profit > 0) {
            stats.profitableEvents++;
        }
    });
    
    stats.averageProfit = events.length > 0 ? stats.totalProfit / events.length : 0;
    
    return stats;
}

function showModal(title, content) {
    const modal = document.getElementById('eventModal');
    const modalContent = document.getElementById('eventModalContent');
    
    if (modal && modalContent) {
        modalContent.innerHTML = `<h3>${title}</h3>${content}`;
        modal.style.display = 'block';
        document.body.style.overflow = 'hidden';
    }
}

function exportCalendar() {
    try {
        const allEvents = [...localSavedEvents, ...plannedEvents, ...historicalData];
        
        let csvContent = 'DONULAND - EXPORT KALEND√Å≈òE\n';
        csvContent += `Datum exportu:,${new Date().toLocaleString('cs-CZ')}\n\n`;
        csvContent += 'N√°zev akce,Datum,Lokalita,Typ,N√°v≈°tƒõvnost,Predikce/Skuteƒçnost,Zisk,Pozn√°mky\n';
        
        allEvents.forEach(event => {
            const eventDate = new Date(event.date || event.eventDate);
            const sales = event.actualSales || event.predictedSales || 0;
            const profit = event.financials ? Math.round(event.financials.profit) : 0;
            
            csvContent += `"${event.eventName || 'Bez n√°zvu'}",`;
            csvContent += `"${eventDate.toLocaleDateString('cs-CZ')}",`;
            csvContent += `"${event.location || 'Nezn√°m√°'}",`;
            csvContent += `"${event.category || event.eventType || 'Ostatn√≠'}",`;
            csvContent += `${event.attendance || event.expectedVisitors || 0},`;
            csvContent += `${sales},`;
            csvContent += `${profit},`;
            csvContent += `"${event.notes || ''}"\n`;
        });
        
        const blob = new Blob(['\ufeff' + csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = `donuland_kalendar_${new Date().toISOString().split('T')[0]}.csv`;
        link.click();
        
        showMessage('Kalend√°≈ô byl exportov√°n', 'success');
    } catch (error) {
        console.error('Export error:', error);
        showMessage('Chyba p≈ôi exportu kalend√°≈ôe', 'error');
    }
}

console.log('üìù ƒå√°st 8 naƒçtena - Kalend√°≈ô a event management');
    // ƒå√ÅST 9: T√ùDENN√ç PL√ÅNOV√ÅN√ç A INVENTORY MANAGEMENT
// P≈ôidejte tuto ƒç√°st za ƒå√°st 8 v <script> tagu

// =============================================================================
// WEEKLY PLANNING SYSTEM
// =============================================================================

function calculateWeeklyPlan() {
    console.log('üìã Calculating weekly plan...');
    
    const currentStock = parseInt(document.getElementById('currentStock')?.value) || 0;
    const safetyBuffer = parseFloat(document.getElementById('safetyBuffer')?.value) || 15;
    
    const startDate = new Date();
    const endDate = new Date();
    endDate.setDate(startDate.getDate() + 7);
    
    const weeklyEvents = getEventsInDateRange(startDate, endDate);
    
    let totalPredictedSales = 0;
    let totalExpectedProfit = 0;
    let eventDetailsHTML = '';
    
    if (weeklyEvents.length === 0) {
        eventDetailsHTML = '<div style="text-align: center; padding: 20px; color: rgba(255,255,255,0.7);">≈Ω√°dn√© pl√°novan√© akce v n√°sleduj√≠c√≠ch 7 dnech</div>';
    } else {
        weeklyEvents.forEach(event => {
            const eventDate = new Date(event.date || event.eventDate);
            const predictedSales = event.predictedSales || estimateEventSales(event);
            const estimatedProfit = event.estimatedProfit || estimateEventFinancials(predictedSales, event).profit;
            
            totalPredictedSales += predictedSales;
            totalExpectedProfit += estimatedProfit;
            
            const profitColor = estimatedProfit >= 0 ? '#00b894' : '#e17055';
            
            eventDetailsHTML += `
                <div style="background: rgba(255,255,255,0.1); padding: 12px; border-radius: 6px; margin: 8px 0; border-left: 4px solid ${profitColor};">
                    <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px;">
                        <div>
                            <strong>${event.eventName || 'Bez n√°zvu'}</strong>
                            <div style="font-size: 0.9em; opacity: 0.9;">
                                üìÖ ${eventDate.toLocaleDateString('cs-CZ')} | üìç ${event.location || 'Nezn√°m√°'}
                            </div>
                        </div>
                        <div style="text-align: right;">
                            <div>üéØ ${predictedSales.toLocaleString('cs-CZ')} ks</div>
                            <div style="color: ${profitColor};">üí∞ ${Math.round(estimatedProfit).toLocaleString('cs-CZ')} Kƒç</div>
                        </div>
                    </div>
                </div>
            `;
        });
    }
    
    // Calculate recommended order
    const bufferAmount = Math.round(totalPredictedSales * (safetyBuffer / 100));
    const totalNeeded = totalPredictedSales + bufferAmount;
    const recommendedOrder = Math.max(0, totalNeeded - currentStock);
    
    // Update UI
    updateWeeklyMetrics(weeklyEvents.length, totalPredictedSales, currentStock, recommendedOrder, totalExpectedProfit);
    updateInventoryStatus(currentStock, totalPredictedSales, recommendedOrder);
    
    document.getElementById('weeklyEventsContent').innerHTML = eventDetailsHTML;
    
    console.log('‚úÖ Weekly plan calculated:', {
        events: weeklyEvents.length,
        totalSales: totalPredictedSales,
        totalProfit: totalExpectedProfit,
        recommendedOrder: recommendedOrder
    });
}

function updateWeeklyMetrics(eventsCount, totalSales, currentStock, recommendedOrder, totalProfit) {
    const elements = {
        weeklyEventsCount: eventsCount,
        weeklyPredictedSales: totalSales.toLocaleString('cs-CZ'),
        currentInventory: currentStock.toLocaleString('cs-CZ'),
        recommendedOrder: recommendedOrder.toLocaleString('cs-CZ'),
        weeklyProfit: Math.round(totalProfit).toLocaleString('cs-CZ')
    };
    
    Object.entries(elements).forEach(([id, value]) => {
        const element = document.getElementById(id);
        if (element) {
            element.textContent = value;
            
            // Add color coding for profit
            if (id === 'weeklyProfit') {
                element.style.color = totalProfit >= 0 ? '#00b894' : '#e17055';
            }
            
            // Add color coding for recommended order
            if (id === 'recommendedOrder') {
                element.style.color = recommendedOrder > 0 ? '#f39c12' : '#00b894';
            }
        }
    });
}

function updateInventoryStatus(currentStock, totalDemand, recommendedOrder) {
    const statusElement = document.getElementById('weeklyInventoryStatus');
    if (!statusElement) return;
    
    if (recommendedOrder <= 0) {
        statusElement.className = 'inventory-ok';
        statusElement.style.display = 'block';
        statusElement.innerHTML = '‚úÖ Skladov√© z√°soby jsou dostateƒçn√© pro pl√°novan√© akce';
    } else {
        statusElement.className = 'inventory-alert';
        statusElement.style.display = 'block';
        const shortage = totalDemand - currentStock;
        statusElement.innerHTML = `‚ö†Ô∏è <strong>Nedostatek z√°sob:</strong> Chyb√≠ ${shortage.toLocaleString('cs-CZ')} ks donut≈Ø pro pokryt√≠ popt√°vky`;
    }
}

function estimateEventSales(event) {
    if (event.predictedSales) return event.predictedSales;
    if (event.actualSales) return event.actualSales;
    
    const visitors = event.expectedVisitors || event.attendance || 1000;
    const eventType = event.eventType || event.category || 'ostatni';
    const duration = event.duration || 1;
    
    // Use same logic as main prediction system
    const conversionRates = {
        'food festival': 0.22,
        'cokoladovy festival': 0.28,
        'rodinny festival': 0.18,
        'kulturni': 0.15,
        'ostatni': 0.12,
        'sportovni': 0.10,
        'veletrh': 0.08,
        'koncert': 0.06
    };
    
    const baseRate = conversionRates[eventType] || 0.12;
    const dailySales = visitors * baseRate;
    
    let durationFactor = 1.0;
    if (duration === 2) durationFactor = 1.75;
    else if (duration === 3) durationFactor = 2.35;
    else if (duration > 3) durationFactor = Math.min(4.0, 1 + (duration - 1) * 0.55);
    
    return Math.round(dailySales * durationFactor);
}

function estimateEventFinancials(sales, event) {
    const businessModel = event.businessModel || 'owner';
    const sellingPrice = 110;
    const donutCost = businessModel === 'franchisee' ? 52 : 32;
    const transportCost = event.transportCost || 500;
    const otherCosts = 200;
    const rentalCost = 5000;
    
    let laborCost = 0;
    if (businessModel === 'owner') {
        laborCost = 3000;
    } else if (businessModel === 'employee') {
        laborCost = 3000 + (sales * sellingPrice * 0.05); // 1500 + 1500 + 5% revenue share
    }
    
    const revenue = sales * sellingPrice;
    const totalCosts = (sales * donutCost) + transportCost + otherCosts + laborCost + rentalCost;
    const profit = revenue - totalCosts;
    
    return {
        revenue,
        totalCosts,
        profit,
        margin: revenue > 0 ? (profit / revenue) * 100 : 0
    };
}

// =============================================================================
// WEEKLY PLANNING ACTIONS
// =============================================================================

function exportWeeklyPlan() {
    const currentStock = parseInt(document.getElementById('currentStock')?.value) || 0;
    const recommendedOrder = parseInt(document.getElementById('recommendedOrder')?.textContent.replace(/\s/g, '')) || 0;
    const totalDemand = parseInt(document.getElementById('weeklyPredictedSales')?.textContent.replace(/\s/g, '')) || 0;
    
    const startDate = new Date();
    const endDate = new Date();
    endDate.setDate(startDate.getDate() + 7);
    
    const weeklyEvents = getEventsInDateRange(startDate, endDate);
    
    let csvContent = 'T√ùDENN√ç PL√ÅN DONULAND\n';
    csvContent += `Obdob√≠:,${startDate.toLocaleDateString('cs-CZ')} - ${endDate.toLocaleDateString('cs-CZ')}\n`;
    csvContent += `Datum exportu:,${new Date().toLocaleString('cs-CZ')}\n\n`;
    
    csvContent += 'SHRNUT√ç SKLADU A OBJEDN√ÅVEK\n';
    csvContent += `Souƒçasn√Ω sklad:,${currentStock} ks\n`;
    csvContent += `Celkov√° popt√°vka:,${totalDemand} ks\n`;
    csvContent += `Doporuƒçen√° objedn√°vka:,${recommendedOrder} ks\n\n`;
    
    csvContent += 'DETAILY AKC√ç\n';
    csvContent += 'N√°zev akce,Datum,Lokalita,Typ,N√°v≈°tƒõvnost,Predikce prodeje (ks),Oƒçek√°van√Ω zisk (Kƒç)\n';
    
    weeklyEvents.forEach(event => {
        const predictedSales = event.predictedSales || estimateEventSales(event);
        const estimatedProfit = event.estimatedProfit || estimateEventFinancials(predictedSales, event).profit;
        
        csvContent += `"${event.eventName || 'Bez n√°zvu'}",`;
        csvContent += `"${new Date(event.date || event.eventDate).toLocaleDateString('cs-CZ')}",`;
        csvContent += `"${event.location || 'Nezn√°m√°'}",`;
        csvContent += `"${event.category || event.eventType || 'Ostatn√≠'}",`;
        csvContent += `${event.attendance || event.expectedVisitors || 0},`;
        csvContent += `${predictedSales},`;
        csvContent += `${Math.round(estimatedProfit)}\n`;
    });
    
    const blob = new Blob(['\ufeff' + csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = `tydenni_plan_${startDate.toISOString().split('T')[0]}.csv`;
    link.click();
    
    showMessage('T√Ωdenn√≠ pl√°n byl exportov√°n', 'success');
}

function createOrderFromPlan() {
    const recommendedOrder = parseInt(document.getElementById('recommendedOrder')?.textContent.replace(/\s/g, '')) || 0;
    
    if (recommendedOrder <= 0) {
        showMessage('≈Ω√°dn√° objedn√°vka nen√≠ pot≈ôeba podle souƒçasn√©ho pl√°nu', 'info');
        return;
    }
    
    const orderSummary = `üì¶ OBJEDN√ÅVKA DONUT≈Æ
    
Mno≈æstv√≠: ${recommendedOrder.toLocaleString('cs-CZ')} ks
Datum objedn√°vky: ${new Date().toLocaleDateString('cs-CZ')}
Oƒçek√°van√© dod√°n√≠: ${new Date(Date.now() + 2 * 24 * 60 * 60 * 1000).toLocaleDateString('cs-CZ')}

Pozn√°mka: Objedn√°vka vygenerov√°na na z√°kladƒõ t√Ωdenn√≠ho pl√°nu akc√≠
vƒçetnƒõ ${document.getElementById('safetyBuffer')?.value || 15}% bezpeƒçnostn√≠ rezervy.`;
    
    navigator.clipboard.writeText(orderSummary).then(() => {
        showMessage(`Objedn√°vka na ${recommendedOrder.toLocaleString('cs-CZ')} ks zkop√≠rov√°na do schr√°nky`, 'success');
    }).catch(() => {
        alert(orderSummary);
        showMessage('Objedn√°vka zobrazena - zkop√≠rujte ruƒçnƒõ', 'info');
    });
}

function syncToSheet() {
    showMessage('Synchronizace se Sheetem zat√≠m nen√≠ implementov√°na', 'info');
}

// =============================================================================
// INVENTORY MANAGEMENT
// =============================================================================

function updateInventoryLevel(newLevel) {
    const stockInput = document.getElementById('currentStock');
    if (stockInput) {
        stockInput.value = newLevel;
        calculateWeeklyPlan();
    }
}

function addToInventory(amount) {
    const stockInput = document.getElementById('currentStock');
    if (stockInput) {
        const currentLevel = parseInt(stockInput.value) || 0;
        stockInput.value = currentLevel + amount;
        calculateWeeklyPlan();
        showMessage(`P≈ôid√°no ${amount.toLocaleString('cs-CZ')} ks do skladu`, 'success');
    }
}

function removeFromInventory(amount) {
    const stockInput = document.getElementById('currentStock');
    if (stockInput) {
        const currentLevel = parseInt(stockInput.value) || 0;
        const newLevel = Math.max(0, currentLevel - amount);
        stockInput.value = newLevel;
        calculateWeeklyPlan();
        showMessage(`Odebr√°no ${amount.toLocaleString('cs-CZ')} ks ze skladu`, 'success');
    }
}

function getInventoryStatus() {
    const currentStock = parseInt(document.getElementById('currentStock')?.value) || 0;
    const startDate = new Date();
    const endDate = new Date();
    endDate.setDate(startDate.getDate() + 7);
    
    const weeklyEvents = getEventsInDateRange(startDate, endDate);
    let totalDemand = 0;
    
    weeklyEvents.forEach(event => {
        totalDemand += estimateEventSales(event);
    });
    
    const shortage = Math.max(0, totalDemand - currentStock);
    const surplus = Math.max(0, currentStock - totalDemand);
    
    return {
        currentStock,
        totalDemand,
        shortage,
        surplus,
        isAdequate: shortage === 0
    };
}

function generateInventoryReport() {
    const status = getInventoryStatus();
    const safetyBuffer = parseFloat(document.getElementById('safetyBuffer')?.value) || 15;
    const recommendedStock = Math.round(status.totalDemand * (1 + safetyBuffer / 100));
    
    const report = `üì¶ INVENT√Å≈ò DONULAND - ${new Date().toLocaleDateString('cs-CZ')}

SOUƒåASN√ù STAV SKLADU
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üè™ Souƒçasn√Ω sklad: ${status.currentStock.toLocaleString('cs-CZ')} ks
üìä T√Ωdenn√≠ popt√°vka: ${status.totalDemand.toLocaleString('cs-CZ')} ks
üéØ Doporuƒçen√Ω sklad: ${recommendedStock.toLocaleString('cs-CZ')} ks
üõ°Ô∏è Bezpeƒçnostn√≠ rezerva: ${safetyBuffer}%

${status.isAdequate ? 
    '‚úÖ STAV SKLADU: DOSTATEƒåN√ù' : 
    `‚ö†Ô∏è STAV SKLADU: NEDOSTATEƒåN√ù (chyb√≠ ${status.shortage.toLocaleString('cs-CZ')} ks)`}

AKCE PRO N√ÅSLEDUJ√çC√ç T√ùDEN
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`;

    const weeklyEvents = getEventsInDateRange(new Date(), new Date(Date.now() + 7 * 24 * 60 * 60 * 1000));
    weeklyEvents.forEach(event => {
        const sales = estimateEventSales(event);
        const date = new Date(event.date || event.eventDate);
        report += `\nüìÖ ${date.toLocaleDateString('cs-CZ')} - ${event.eventName || 'Bez n√°zvu'}: ${sales.toLocaleString('cs-CZ')} ks`;
    });
    
    return report;
}

// =============================================================================
// PLANNING UTILITIES AND OPTIMIZATION
// =============================================================================

function optimizeWeeklySchedule() {
    const weeklyEvents = getEventsInDateRange(new Date(), new Date(Date.now() + 7 * 24 * 60 * 60 * 1000));
    
    if (weeklyEvents.length === 0) {
        showMessage('≈Ω√°dn√© akce k optimalizaci', 'info');
        return;
    }
    
    // Sort events by profitability
    const optimizedEvents = weeklyEvents.sort((a, b) => {
        const profitA = estimateEventFinancials(estimateEventSales(a), a).profit;
        const profitB = estimateEventFinancials(estimateEventSales(b), b).profit;
        return profitB - profitA;
    });
    
    let recommendations = 'üéØ OPTIMALIZACE T√ùDENN√çHO PL√ÅNU\n\n';
    recommendations += 'PRIORITA AKC√ç (podle ziskovosti):\n';
    
    optimizedEvents.forEach((event, index) => {
        const sales = estimateEventSales(event);
        const profit = estimateEventFinancials(sales, event).profit;
        const priority = index < 3 ? 'üî• VYSOK√Å' : index < 6 ? '‚ö° ST≈òEDN√ç' : 'üí° N√çZK√Å';
        
        recommendations += `${index + 1}. ${event.eventName || 'Bez n√°zvu'} - ${priority}\n`;
        recommendations += `   üí∞ Zisk: ${Math.round(profit).toLocaleString('cs-CZ')} Kƒç | üìä Prodej: ${sales.toLocaleString('cs-CZ')} ks\n\n`;
    });
    
    // Find conflicts (same day events)
    const conflicts = findScheduleConflicts(optimizedEvents);
    if (conflicts.length > 0) {
        recommendations += 'KONFLIKTY TERM√çN≈Æ:\n';
        conflicts.forEach(conflict => {
            recommendations += `‚ö†Ô∏è ${conflict.date}: ${conflict.events.map(e => e.eventName || 'Bez n√°zvu').join(', ')}\n`;
        });
    }
    
    navigator.clipboard.writeText(recommendations).then(() => {
        showMessage('Optimalizovan√© doporuƒçen√≠ zkop√≠rov√°no do schr√°nky', 'success');
    }).catch(() => {
        alert(recommendations);
    });
}

function findScheduleConflicts(events) {
    const conflicts = [];
    const eventsByDate = {};
    
    events.forEach(event => {
        const dateKey = new Date(event.date || event.eventDate).toDateString();
        if (!eventsByDate[dateKey]) {
            eventsByDate[dateKey] = [];
        }
        eventsByDate[dateKey].push(event);
    });
    
    Object.entries(eventsByDate).forEach(([date, eventsOnDate]) => {
        if (eventsOnDate.length > 1) {
            conflicts.push({
                date: new Date(date).toLocaleDateString('cs-CZ'),
                events: eventsOnDate
            });
        }
    });
    
    return conflicts;
}

function calculateResourceRequirements() {
    const weeklyEvents = getEventsInDateRange(new Date(), new Date(Date.now() + 7 * 24 * 60 * 60 * 1000));
    
    let totalStaffHours = 0;
    let totalTransportDistance = 0;
    let peakDayEvents = 0;
    const staffByDay = {};
    
    weeklyEvents.forEach(event => {
        const eventDate = new Date(event.date || event.eventDate);
        const dateKey = eventDate.toDateString();
        
        // Calculate staff requirements
        const baseHours = (event.duration || 1) * 10; // 10 hours per day
        const staffCount = event.businessModel === 'owner' ? 3 : 2; // owner + 2 brigade vs employee + 1 brigade
        const eventStaffHours = baseHours * staffCount;
        
        totalStaffHours += eventStaffHours;
        
        if (!staffByDay[dateKey]) {
            staffByDay[dateKey] = 0;
        }
        staffByDay[dateKey] += staffCount;
        
        // Track peak day
        peakDayEvents = Math.max(peakDayEvents, staffByDay[dateKey]);
    });
    
    return {
        totalStaffHours,
        peakDayStaff: peakDayEvents,
        averageDailyStaff: totalStaffHours / 7,
        totalEvents: weeklyEvents.length
    };
}

// =============================================================================
// PERFORMANCE ANALYTICS FOR WEEKLY PLANNING
// =============================================================================

function analyzeWeeklyPerformance() {
    const currentWeek = getEventsInDateRange(new Date(), new Date(Date.now() + 7 * 24 * 60 * 60 * 1000));
    const lastWeek = getEventsInDateRange(new Date(Date.now() - 7 * 24 * 60 * 60 * 1000), new Date());
    
    const currentWeekStats = calculateWeekStats(currentWeek);
    const lastWeekStats = calculateWeekStats(lastWeek);
    
    const comparison = {
        eventsChange: currentWeekStats.events - lastWeekStats.events,
        salesChange: currentWeekStats.totalSales - lastWeekStats.totalSales,
        profitChange: currentWeekStats.totalProfit - lastWeekStats.totalProfit,
        avgProfitChange: currentWeekStats.avgProfit - lastWeekStats.avgProfit
    };
    
    return {
        current: currentWeekStats,
        last: lastWeekStats,
        comparison
    };
}

function calculateWeekStats(events) {
    let totalSales = 0;
    let totalProfit = 0;
    
    events.forEach(event => {
        const sales = event.actualSales || estimateEventSales(event);
        const financials = event.financials || estimateEventFinancials(sales, event);
        
        totalSales += sales;
        totalProfit += financials.profit;
    });
    
    return {
        events: events.length,
        totalSales,
        totalProfit,
        avgProfit: events.length > 0 ? totalProfit / events.length : 0
    };
}

console.log('üìù ƒå√°st 9 naƒçtena - T√Ωdenn√≠ pl√°nov√°n√≠ a inventory management');
    // ƒå√ÅST 10: ANALYTICS A TRENDY
// P≈ôidejte tuto ƒç√°st za ƒå√°st 9 v <script> tagu

// =============================================================================
// ANALYTICS SYSTEM
// =============================================================================

function loadAnalytics() {
    const analyticsContent = document.getElementById('analyticsContent');
    
    if (historicalData.length === 0) {
        analyticsContent.innerHTML = `
            <div style="text-align: center; padding: 60px 20px; color: #7f8c8d;">
                <div style="font-size: 4em; margin-bottom: 20px; opacity: 0.3;">üìä</div>
                <h3 style="margin-bottom: 15px; color: #34495e;">Anal√Ωza prodejn√≠ch dat</h3>
                <p style="font-size: 1.1em; margin-bottom: 25px;">Zat√≠m nejsou dostupn√° ≈æ√°dn√° historick√° data pro anal√Ωzu.</p>
                <p style="margin-bottom: 30px;">Data se naƒçtou automaticky z Google Sheetu nebo m≈Ø≈æete vytvo≈ôit nov√© predikce.</p>
                <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
                    <button class="btn btn-primary btn-large" onclick="loadData()">üîÑ Naƒç√≠st data ze Sheetu</button>
                    <button class="btn btn-success" onclick="showTab('prediction', {target: document.querySelector('.nav-tab')})">ü§ñ Vytvo≈ôit predikci</button>
                </div>
            </div>
        `;
        return;
    }
    
    console.log('üìä Loading analytics with', historicalData.length, 'historical events');
    
    const analytics = generateAnalytics();
    displayAnalytics(analytics);
}

function generateAnalytics() {
    const analytics = {
        overview: calculateOverviewStats(),
        trends: calculateTrends(),
        performance: calculatePerformanceMetrics(),
        predictions: analyzePredictionAccuracy(),
        seasonal: analyzeSeasonalPatterns(),
        profitability: analyzeProfitability(),
        eventTypes: analyzeEventTypes(),
        locations: analyzeLocations()
    };
    
    return analytics;
}

function calculateOverviewStats() {
    let totalEvents = historicalData.length;
    let totalSales = 0;
    let totalRevenue = 0;
    let totalProfit = 0;
    let avgRating = 0;
    let ratingCount = 0;
    
    historicalData.forEach(event => {
        totalSales += event.actualSales || 0;
        totalRevenue += (event.actualSales || 0) * 110; // Default selling price
        
        if (event.rating && event.rating > 0) {
            avgRating += event.rating;
            ratingCount++;
        }
        
        // Estimate profit if not available
        if (event.actualSales) {
            const estimatedFinancials = estimateEventFinancials(event.actualSales, event);
            totalProfit += estimatedFinancials.profit;
        }
    });
    
    return {
        totalEvents,
        totalSales,
        totalRevenue,
        totalProfit,
        avgSales: totalEvents > 0 ? totalSales / totalEvents : 0,
        avgRevenue: totalEvents > 0 ? totalRevenue / totalEvents : 0,
        avgProfit: totalEvents > 0 ? totalProfit / totalEvents : 0,
        avgRating: ratingCount > 0 ? avgRating / ratingCount : 0,
        avgConversion: calculateAverageConversion()
    };
}

function calculateAverageConversion() {
    let totalConversion = 0;
    let validEvents = 0;
    
    historicalData.forEach(event => {
        if (event.actualSales && event.attendance && event.attendance > 0) {
            totalConversion += (event.actualSales / event.attendance) * 100;
            validEvents++;
        }
    });
    
    return validEvents > 0 ? totalConversion / validEvents : 0;
}

function calculateTrends() {
    const monthlyData = {};
    
    historicalData.forEach(event => {
        const date = new Date(event.eventDate || event.date);
        const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
        
        if (!monthlyData[monthKey]) {
            monthlyData[monthKey] = {
                events: 0,
                sales: 0,
                revenue: 0,
                profit: 0
            };
        }
        
        monthlyData[monthKey].events++;
        monthlyData[monthKey].sales += event.actualSales || 0;
        monthlyData[monthKey].revenue += (event.actualSales || 0) * 110;
        
        if (event.actualSales) {
            const estimatedFinancials = estimateEventFinancials(event.actualSales, event);
            monthlyData[monthKey].profit += estimatedFinancials.profit;
        }
    });
    
    // Calculate month-over-month growth
    const sortedMonths = Object.keys(monthlyData).sort();
    const trends = {
        monthly: monthlyData,
        growth: calculateGrowthRates(sortedMonths, monthlyData)
    };
    
    return trends;
}

function calculateGrowthRates(sortedMonths, monthlyData) {
    const growth = {
        sales: [],
        revenue: [],
        events: []
    };
    
    for (let i = 1; i < sortedMonths.length; i++) {
        const currentMonth = sortedMonths[i];
        const previousMonth = sortedMonths[i - 1];
        
        const current = monthlyData[currentMonth];
        const previous = monthlyData[previousMonth];
        
        if (previous.sales > 0) {
            growth.sales.push({
                month: currentMonth,
                rate: ((current.sales - previous.sales) / previous.sales) * 100
            });
        }
        
        if (previous.revenue > 0) {
            growth.revenue.push({
                month: currentMonth,
                rate: ((current.revenue - previous.revenue) / previous.revenue) * 100
            });
        }
        
        if (previous.events > 0) {
            growth.events.push({
                month: currentMonth,
                rate: ((current.events - previous.events) / previous.events) * 100
            });
        }
    }
    
    return growth;
}

function calculatePerformanceMetrics() {
    const topEvents = [...historicalData]
        .filter(event => event.actualSales > 0)
        .sort((a, b) => b.actualSales - a.actualSales)
        .slice(0, 10);
    
    const bottomEvents = [...historicalData]
        .filter(event => event.actualSales > 0)
        .sort((a, b) => a.actualSales - b.actualSales)
        .slice(0, 5);
    
    return {
        topPerformers: topEvents,
        underPerformers: bottomEvents,
        averageBySize: calculatePerformanceBySize(),
        seasonalPerformance: calculateSeasonalPerformance()
    };
}

function calculatePerformanceBySize() {
    const sizeCategories = {
        small: { events: [], threshold: [0, 2000] },
        medium: { events: [], threshold: [2000, 5000] },
        large: { events: [], threshold: [5000, 10000] },
        xlarge: { events: [], threshold: [10000, Infinity] }
    };
    
    historicalData.forEach(event => {
        const attendance = event.attendance || event.expectedVisitors || 0;
        
        for (const [category, data] of Object.entries(sizeCategories)) {
            if (attendance >= data.threshold[0] && attendance < data.threshold[1]) {
                data.events.push(event);
                break;
            }
        }
    });
    
    const results = {};
    Object.entries(sizeCategories).forEach(([category, data]) => {
        if (data.events.length > 0) {
            const avgSales = data.events.reduce((sum, e) => sum + (e.actualSales || 0), 0) / data.events.length;
            const avgConversion = data.events.reduce((sum, e) => {
                const attendance = e.attendance || e.expectedVisitors || 1;
                return sum + ((e.actualSales || 0) / attendance * 100);
            }, 0) / data.events.length;
            
            results[category] = {
                count: data.events.length,
                avgSales: Math.round(avgSales),
                avgConversion: avgConversion.toFixed(2)
            };
        }
    });
    
    return results;
}

function calculateSeasonalPerformance() {
    const seasons = {
        spring: { months: [3, 4, 5], events: [] },
        summer: { months: [6, 7, 8], events: [] },
        autumn: { months: [9, 10, 11], events: [] },
        winter: { months: [12, 1, 2], events: [] }
    };
    
    historicalData.forEach(event => {
        const date = new Date(event.eventDate || event.date);
        const month = date.getMonth() + 1;
        
        for (const [season, data] of Object.entries(seasons)) {
            if (data.months.includes(month)) {
                data.events.push(event);
                break;
            }
        }
    });
    
    const results = {};
    Object.entries(seasons).forEach(([season, data]) => {
        if (data.events.length > 0) {
            const avgSales = data.events.reduce((sum, e) => sum + (e.actualSales || 0), 0) / data.events.length;
            const totalSales = data.events.reduce((sum, e) => sum + (e.actualSales || 0), 0);
            
            results[season] = {
                count: data.events.length,
                avgSales: Math.round(avgSales),
                totalSales: totalSales,
                bestEvent: data.events.reduce((best, current) => 
                    (current.actualSales || 0) > (best.actualSales || 0) ? current : best
                )
            };
        }
    });
    
    return results;
}

function analyzePredictionAccuracy() {
    const eventsWithPredictions = historicalData.filter(event => 
        event.actualSales > 0 && event.estimatedSales > 0
    );
    
    if (eventsWithPredictions.length === 0) {
        return {
            accuracy: 0,
            avgError: 0,
            totalComparisons: 0
        };
    }
    
    let totalAccuracy = 0;
    let totalAbsoluteError = 0;
    
    eventsWithPredictions.forEach(event => {
        const accuracy = Math.min(100, (event.actualSales / event.estimatedSales) * 100);
        const error = Math.abs(event.actualSales - event.estimatedSales);
        
        totalAccuracy += accuracy;
        totalAbsoluteError += error;
    });
    
    return {
        accuracy: totalAccuracy / eventsWithPredictions.length,
        avgError: totalAbsoluteError / eventsWithPredictions.length,
        totalComparisons: eventsWithPredictions.length,
        bestPredictions: eventsWithPredictions
            .map(event => ({
                ...event,
                accuracy: Math.min(100, (event.actualSales / event.estimatedSales) * 100)
            }))
            .sort((a, b) => b.accuracy - a.accuracy)
            .slice(0, 5),
        worstPredictions: eventsWithPredictions
            .map(event => ({
                ...event,
                accuracy: Math.min(100, (event.actualSales / event.estimatedSales) * 100)
            }))
            .sort((a, b) => a.accuracy - b.accuracy)
            .slice(0, 5)
    };
}

function analyzeSeasonalPatterns() {
    const monthlyStats = {};
    
    for (let month = 1; month <= 12; month++) {
        monthlyStats[month] = {
            events: 0,
            totalSales: 0,
            avgSales: 0,
            avgConversion: 0
        };
    }
    
    historicalData.forEach(event => {
        const date = new Date(event.eventDate || event.date);
        const month = date.getMonth() + 1;
        
        monthlyStats[month].events++;
        monthlyStats[month].totalSales += event.actualSales || 0;
    });
    
    // Calculate averages
    Object.values(monthlyStats).forEach(stats => {
        if (stats.events > 0) {
            stats.avgSales = stats.totalSales / stats.events;
        }
    });
    
    return monthlyStats;
}

function analyzeProfitability() {
    const profitableEvents = historicalData.filter(event => {
        if (!event.actualSales) return false;
        const financials = estimateEventFinancials(event.actualSales, event);
        return financials.profit > 0;
    });
    
    const unprofitableEvents = historicalData.filter(event => {
        if (!event.actualSales) return false;
        const financials = estimateEventFinancials(event.actualSales, event);
        return financials.profit <= 0;
    });
    
    const totalProfitable = profitableEvents.length;
    const totalUnprofitable = unprofitableEvents.length;
    const profitabilityRate = historicalData.length > 0 ? 
        (totalProfitable / historicalData.length) * 100 : 0;
    
    return {
        profitabilityRate,
        totalProfitable,
        totalUnprofitable,
        avgProfitableRevenue: totalProfitable > 0 ? 
            profitableEvents.reduce((sum, e) => sum + (e.actualSales * 110), 0) / totalProfitable : 0,
        topProfitableEvents: profitableEvents
            .map(event => ({
                ...event,
                estimatedProfit: estimateEventFinancials(event.actualSales, event).profit
            }))
            .sort((a, b) => b.estimatedProfit - a.estimatedProfit)
            .slice(0, 5)
    };
}

function analyzeEventTypes() {
    const typeStats = {};
    
    historicalData.forEach(event => {
        const category = event.category || event.eventType || 'Ostatn√≠';
        
        if (!typeStats[category]) {
            typeStats[category] = {
                events: 0,
                totalSales: 0,
                avgSales: 0,
                avgConversion: 0,
                bestEvent: null
            };
        }
        
        typeStats[category].events++;
        typeStats[category].totalSales += event.actualSales || 0;
        
        if (!typeStats[category].bestEvent || 
            (event.actualSales || 0) > (typeStats[category].bestEvent.actualSales || 0)) {
            typeStats[category].bestEvent = event;
        }
    });
    
    // Calculate averages and sort by performance
    const sortedTypes = Object.entries(typeStats)
        .map(([type, stats]) => ({
            type,
            ...stats,
            avgSales: stats.events > 0 ? stats.totalSales / stats.events : 0
        }))
        .sort((a, b) => b.avgSales - a.avgSales);
    
    return sortedTypes;
}

function analyzeLocations() {
    const locationStats = {};
    
    historicalData.forEach(event => {
        const location = event.location || 'Nezn√°m√°';
        
        if (!locationStats[location]) {
            locationStats[location] = {
                events: 0,
                totalSales: 0,
                avgSales: 0,
                bestEvent: null
            };
        }
        
        locationStats[location].events++;
        locationStats[location].totalSales += event.actualSales || 0;
        
        if (!locationStats[location].bestEvent || 
            (event.actualSales || 0) > (locationStats[location].bestEvent.actualSales || 0)) {
            locationStats[location].bestEvent = event;
        }
    });
    
    // Calculate averages and sort by performance
    const sortedLocations = Object.entries(locationStats)
        .map(([location, stats]) => ({
            location,
            ...stats,
            avgSales: stats.events > 0 ? stats.totalSales / stats.events : 0
        }))
        .filter(item => item.events >= 2) // Only show locations with 2+ events
        .sort((a, b) => b.avgSales - a.avgSales)
        .slice(0, 10); // Top 10 locations
    
    return sortedLocations;
}

// =============================================================================
// ANALYTICS DISPLAY
// =============================================================================

function displayAnalytics(analytics) {
    const analyticsContent = document.getElementById('analyticsContent');
    
    const html = `
        <div style="display: grid; gap: 20px;">
            ${createOverviewSection(analytics.overview)}
            ${createTrendsSection(analytics.trends)}
            ${createPerformanceSection(analytics.performance)}
            ${createPredictionAccuracySection(analytics.predictions)}
            ${createProfitabilitySection(analytics.profitability)}
            ${createEventTypesSection(analytics.eventTypes)}
            ${createLocationsSection(analytics.locations)}
            ${createSeasonalSection(analytics.seasonal)}
        </div>
        
        <div style="text-align: center; margin-top: 30px;">
            <button class="btn btn-primary btn-large" onclick="exportAnalytics()">üìä Export anal√Ωzy</button>
            <button class="btn btn-success" onclick="generateAnalyticsReport()">üìã Vytvo≈ôit report</button>
        </div>
    `;
    
    analyticsContent.innerHTML = html;
}

function createOverviewSection(overview) {
    return `
        <div class="form-section">
            <h3>üìä Celkov√Ω p≈ôehled</h3>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                <div style="background: linear-gradient(135deg, #3498db, #2980b9); color: white; padding: 20px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 2em; font-weight: bold;">${overview.totalEvents}</div>
                    <div>Celkem akc√≠</div>
                </div>
                <div style="background: linear-gradient(135deg, #27ae60, #219a52); color: white; padding: 20px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 2em; font-weight: bold;">${overview.totalSales.toLocaleString('cs-CZ')}</div>
                    <div>Celkem prod√°no (ks)</div>
                </div>
                <div style="background: linear-gradient(135deg, #f39c12, #e67e22); color: white; padding: 20px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 2em; font-weight: bold;">${Math.round(overview.totalRevenue).toLocaleString('cs-CZ')} Kƒç</div>
                    <div>Celkov√Ω obrat</div>
                </div>
                <div style="background: linear-gradient(135deg, #9b59b6, #8e44ad); color: white; padding: 20px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 2em; font-weight: bold;">${Math.round(overview.avgSales).toLocaleString('cs-CZ')}</div>
                    <div>Pr≈Ømƒõr na akci (ks)</div>
                </div>
                <div style="background: linear-gradient(135deg, #e74c3c, #c0392b); color: white; padding: 20px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 2em; font-weight: bold;">${overview.avgConversion.toFixed(1)}%</div>
                    <div>Konverzn√≠ pomƒõr</div>
                </div>
                ${overview.avgRating > 0 ? `
                <div style="background: linear-gradient(135deg, #16a085, #1abc9c); color: white; padding: 20px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 2em; font-weight: bold;">${overview.avgRating.toFixed(1)}/5</div>
                    <div>Pr≈Ømƒõrn√© hodnocen√≠</div>
                </div>
                ` : ''}
            </div>
        </div>
    `;
}

function createTrendsSection(trends) {
    const monthlyData = trends.monthly;
    const sortedMonths = Object.keys(monthlyData).sort().slice(-6); // Last 6 months
    
    let trendsHTML = `
        <div class="form-section">
            <h3>üìà Trendy a r≈Øst</h3>
            <div style="overflow-x: auto;">
                <table style="width: 100%; border-collapse: collapse;">
                    <thead>
                        <tr style="background: #f8f9fa;">
                            <th style="padding: 10px; border: 1px solid #ddd;">Mƒõs√≠c</th>
                            <th style="padding: 10px; border: 1px solid #ddd;">Akce</th>
                            <th style="padding: 10px; border: 1px solid #ddd;">Prodej (ks)</th>
                            <th style="padding: 10px; border: 1px solid #ddd;">Obrat (Kƒç)</th>
                            <th style="padding: 10px; border: 1px solid #ddd;">Pr≈Ømƒõr/akci</th>
                        </tr>
                    </thead>
                    <tbody>
    `;
    
    sortedMonths.forEach(month => {
        const data = monthlyData[month];
        const avgPerEvent = data.events > 0 ? data.sales / data.events : 0;
        
        trendsHTML += `
            <tr>
                <td style="padding: 10px; border: 1px solid #ddd;">${month}</td>
                <td style="padding: 10px; border: 1px solid #ddd;">${data.events}</td>
                <td style="padding: 10px; border: 1px solid #ddd;">${data.sales.toLocaleString('cs-CZ')}</td>
                <td style="padding: 10px; border: 1px solid #ddd;">${Math.round(data.revenue).toLocaleString('cs-CZ')}</td>
                <td style="padding: 10px; border: 1px solid #ddd;">${Math.round(avgPerEvent).toLocaleString('cs-CZ')}</td>
            </tr>
        `;
    });
    
    trendsHTML += `
                    </tbody>
                </table>
            </div>
        </div>
    `;
    
    return trendsHTML;
}

function createPerformanceSection(performance) {
    let html = `
        <div class="form-section">
            <h3>üèÜ V√Ωkonnost akc√≠</h3>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                <div>
                    <h4>üíé Nejziskovƒõj≈°√≠ akce</h4>
            ${profitability.topProfitableEvents.slice(0, 3).map(event => `
                <div style="background: #d4edda; padding: 10px; border-radius: 6px; margin: 8px 0;">
                    <strong>${event.eventName || 'Bez n√°zvu'}</strong>
                    <div style="font-size: 0.9em; color: #155724;">
                        Zisk: ${Math.round(event.estimatedProfit).toLocaleString('cs-CZ')} Kƒç | 
                        Prodej: ${event.actualSales.toLocaleString('cs-CZ')} ks | 
                        üìç ${event.location || 'Nezn√°m√°'}
                    </div>
                </div>
            `).join('')}
        </div>
    `;
}

function createEventTypesSection(eventTypes) {
    return `
        <div class="form-section">
            <h3>üé™ Anal√Ωza typ≈Ø akc√≠</h3>
            <div style="overflow-x: auto;">
                <table style="width: 100%; border-collapse: collapse;">
                    <thead>
                        <tr style="background: #f8f9fa;">
                            <th style="padding: 10px; border: 1px solid #ddd;">Typ akce</th>
                            <th style="padding: 10px; border: 1px solid #ddd;">Poƒçet akc√≠</th>
                            <th style="padding: 10px; border: 1px solid #ddd;">Celkem prod√°no</th>
                            <th style="padding: 10px; border: 1px solid #ddd;">Pr≈Ømƒõr na akci</th>
                            <th style="padding: 10px; border: 1px solid #ddd;">Nejlep≈°√≠ akce</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${eventTypes.map(type => `
                            <tr>
                                <td style="padding: 10px; border: 1px solid #ddd;"><strong>${type.type}</strong></td>
                                <td style="padding: 10px; border: 1px solid #ddd;">${type.events}</td>
                                <td style="padding: 10px; border: 1px solid #ddd;">${type.totalSales.toLocaleString('cs-CZ')} ks</td>
                                <td style="padding: 10px; border: 1px solid #ddd;">${Math.round(type.avgSales).toLocaleString('cs-CZ')} ks</td>
                                <td style="padding: 10px; border: 1px solid #ddd;">
                                    ${type.bestEvent ? `${type.bestEvent.eventName || 'Bez n√°zvu'} (${(type.bestEvent.actualSales || 0).toLocaleString('cs-CZ')} ks)` : 'N/A'}
                                </td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            </div>
        </div>
    `;
}

function createLocationsSection(locations) {
    if (locations.length === 0) {
        return `
            <div class="form-section">
                <h3>üìç Anal√Ωza lokalit</h3>
                <p style="text-align: center; color: #7f8c8d;">Nedostatek dat pro anal√Ωzu lokalit (vy≈æaduje min. 2 akce na lokalitu).</p>
            </div>
        `;
    }
    
    return `
        <div class="form-section">
            <h3>üìç Top lokality</h3>
            <div style="display: grid; gap: 10px;">
                ${locations.map((location, index) => `
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; border-left: 4px solid ${index < 3 ? '#27ae60' : '#3498db'};">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <strong>${index + 1}. ${location.location}</strong>
                                <div style="font-size: 0.9em; color: #7f8c8d;">
                                    ${location.events} akc√≠ | Nejlep≈°√≠: ${location.bestEvent ? location.bestEvent.eventName || 'Bez n√°zvu' : 'N/A'}
                                </div>
                            </div>
                            <div style="text-align: right;">
                                <div style="font-size: 1.2em; font-weight: bold;">${Math.round(location.avgSales).toLocaleString('cs-CZ')} ks</div>
                                <div style="font-size: 0.9em; color: #7f8c8d;">pr≈Ømƒõr/akci</div>
                            </div>
                        </div>
                    </div>
                `).join('')}
            </div>
        </div>
    `;
}

function createSeasonalSection(seasonal) {
    const months = [
        'Leden', '√önor', 'B≈ôezen', 'Duben', 'Kvƒõten', 'ƒåerven',
        'ƒåervenec', 'Srpen', 'Z√°≈ô√≠', '≈ò√≠jen', 'Listopad', 'Prosinec'
    ];
    
    return `
        <div class="form-section">
            <h3>üóìÔ∏è Sez√≥nn√≠ anal√Ωza</h3>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px;">
                ${months.map((monthName, index) => {
                    const monthData = seasonal[index + 1] || { events: 0, avgSales: 0 };
                    const intensity = monthData.avgSales > 0 ? Math.min(1, monthData.avgSales / 1000) : 0;
                    const bgColor = intensity > 0.7 ? '#27ae60' : intensity > 0.4 ? '#f39c12' : intensity > 0 ? '#3498db' : '#95a5a6';
                    
                    return `
                        <div style="background: ${bgColor}; color: white; padding: 12px; border-radius: 8px; text-align: center;">
                            <div style="font-weight: bold; font-size: 0.9em;">${monthName}</div>
                            <div style="font-size: 1.2em; margin: 5px 0;">${monthData.events}</div>
                            <div style="font-size: 0.8em;">akc√≠</div>
                            ${monthData.avgSales > 0 ? `<div style="font-size: 0.8em; margin-top: 5px;">${Math.round(monthData.avgSales)} ks/akci</div>` : ''}
                        </div>
                    `;
                }).join('')}
            </div>
        </div>
    `;
}

// =============================================================================
// ANALYTICS EXPORT AND REPORTING
// =============================================================================

function exportAnalytics() {
    try {
        const analytics = generateAnalytics();
        
        let csvContent = 'DONULAND - ANALYTICK√ù REPORT\n';
        csvContent += `Datum exportu:,${new Date().toLocaleString('cs-CZ')}\n`;
        csvContent += `Poƒçet analyzovan√Ωch akc√≠:,${historicalData.length}\n\n`;
        
        // Overview
        csvContent += 'CELKOV√ù P≈òEHLED\n';
        csvContent += `Celkem akc√≠:,${analytics.overview.totalEvents}\n`;
        csvContent += `Celkem prod√°no:,${analytics.overview.totalSales} ks\n`;
        csvContent += `Celkov√Ω obrat:,${Math.round(analytics.overview.totalRevenue)} Kƒç\n`;
        csvContent += `Pr≈Ømƒõr na akci:,${Math.round(analytics.overview.avgSales)} ks\n`;
        csvContent += `Konverzn√≠ pomƒõr:,${analytics.overview.avgConversion.toFixed(2)}%\n\n`;
        
        // Event types
        csvContent += 'ANAL√ùZA TYP≈Æ AKC√ç\n';
        csvContent += 'Typ akce,Poƒçet akc√≠,Celkem prod√°no,Pr≈Ømƒõr na akci\n';
        analytics.eventTypes.forEach(type => {
            csvContent += `"${type.type}",${type.events},${type.totalSales},${Math.round(type.avgSales)}\n`;
        });
        csvContent += '\n';
        
        // Top locations
        csvContent += 'TOP LOKALITY\n';
        csvContent += 'Lokalita,Poƒçet akc√≠,Celkem prod√°no,Pr≈Ømƒõr na akci\n';
        analytics.locations.forEach(location => {
            csvContent += `"${location.location}",${location.events},${location.totalSales},${Math.round(location.avgSales)}\n`;
        });
        csvContent += '\n';
        
        // Profitability
        csvContent += 'ZISKOVOST\n';
        csvContent += `M√≠ra ziskovosti:,${analytics.profitability.profitabilityRate.toFixed(1)}%\n`;
        csvContent += `Ziskov√© akce:,${analytics.profitability.totalProfitable}\n`;
        csvContent += `Ztr√°tov√© akce:,${analytics.profitability.totalUnprofitable}\n\n`;
        
        const blob = new Blob(['\ufeff' + csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = `donuland_analytics_${new Date().toISOString().split('T')[0]}.csv`;
        link.click();
        
        showMessage('Analytick√Ω report byl exportov√°n', 'success');
    } catch (error) {
        console.error('Analytics export error:', error);
        showMessage('Chyba p≈ôi exportu anal√Ωz', 'error');
    }
}

function generateAnalyticsReport() {
    const analytics = generateAnalytics();
    
    const report = `üìä DONULAND - ANALYTICK√ù REPORT
${new Date().toLocaleDateString('cs-CZ')}

SHRNUT√ç V√ùKONNOSTI
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üé™ Celkem akc√≠: ${analytics.overview.totalEvents}
üìä Celkem prod√°no: ${analytics.overview.totalSales.toLocaleString('cs-CZ')} ks
üí∞ Celkov√Ω obrat: ${Math.round(analytics.overview.totalRevenue).toLocaleString('cs-CZ')} Kƒç
üìà Pr≈Ømƒõr na akci: ${Math.round(analytics.overview.avgSales).toLocaleString('cs-CZ')} ks
üéØ Konverzn√≠ pomƒõr: ${analytics.overview.avgConversion.toFixed(2)}%

ZISKOVOST
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üíé M√≠ra ziskovosti: ${analytics.profitability.profitabilityRate.toFixed(1)}%
‚úÖ Ziskov√© akce: ${analytics.profitability.totalProfitable}
‚ùå Ztr√°tov√© akce: ${analytics.profitability.totalUnprofitable}

NEJLEP≈†√ç TYPY AKC√ç
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`;

    analytics.eventTypes.slice(0, 5).forEach((type, index) => {
        report += `\n${index + 1}. ${type.type}: ${Math.round(type.avgSales).toLocaleString('cs-CZ')} ks/akci (${type.events} akc√≠)`;
    });

    report += `\n\nTOP LOKALITY
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`;

    analytics.locations.slice(0, 5).forEach((location, index) => {
        report += `\n${index + 1}. ${location.location}: ${Math.round(location.avgSales).toLocaleString('cs-CZ')} ks/akci (${location.events} akc√≠)`;
    });

    if (analytics.predictions.totalComparisons > 0) {
        report += `\n\nP≈òESNOST PREDIKCE
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üéØ Pr≈Ømƒõrn√° p≈ôesnost: ${analytics.predictions.accuracy.toFixed(1)}%
üìä Pr≈Ømƒõrn√° chyba: ${Math.round(analytics.predictions.avgError).toLocaleString('cs-CZ')} ks
üìà Porovn√°n√≠ celkem: ${analytics.predictions.totalComparisons}`;
    }

    report += `\n\nDOPORUƒåEN√ç
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`;

    // Generate recommendations based on data
    if (analytics.eventTypes.length > 0) {
        const bestType = analytics.eventTypes[0];
        report += `\nüéØ Zamƒõ≈ôte se na typ "${bestType.type}" - nejlep≈°√≠ pr≈Ømƒõrn√Ω v√Ωkon`;
    }

    if (analytics.locations.length > 0) {
        const bestLocation = analytics.locations[0];
        report += `\nüìç Prioritizujte lokality jako "${bestLocation.location}" - prok√°zanƒõ √∫spƒõ≈°n√©`;
    }

    if (analytics.profitability.profitabilityRate < 70) {
        report += `\nüí° Zvy≈°te ziskovost - souƒçasn√° m√≠ra ${analytics.profitability.profitabilityRate.toFixed(1)}% m√° prostor ke zlep≈°en√≠`;
    }

    navigator.clipboard.writeText(report).then(() => {
        showMessage('Analytick√Ω report zkop√≠rov√°n do schr√°nky', 'success');
    }).catch(() => {
        alert(report);
        showMessage('Report zobrazen - zkop√≠rujte ruƒçnƒõ', 'info');
    });
}

// =============================================================================
// ANALYTICS UTILITIES
// =============================================================================

function getTopPerformingMonths() {
    const seasonal = analyzeSeasonalPatterns();
    return Object.entries(seasonal)
        .filter(([month, data]) => data.events > 0)
        .sort((a, b) => b[1].avgSales - a[1].avgSales)
        .slice(0, 3);
}

function predictOptimalEventTypes(location = null) {
    const eventTypes = analyzeEventTypes();
    
    if (location) {
        // Filter by location if specified
        const locationEvents = historicalData.filter(event => 
            event.location && event.location.toLowerCase() === location.toLowerCase()
        );
        
        if (locationEvents.length > 0) {
            return analyzeEventTypesForLocation(locationEvents);
        }
    }
    
    return eventTypes.slice(0, 3).map(type => ({
        type: type.type,
        avgSales: type.avgSales,
        confidence: Math.min(95, type.events * 5) // Confidence based on sample size
    }));
}

function analyzeEventTypesForLocation(locationEvents) {
    const typeStats = {};
    
    locationEvents.forEach(event => {
        const category = event.category || event.eventType || 'Ostatn√≠';
        
        if (!typeStats[category]) {
            typeStats[category] = { events: 0, totalSales: 0 };
        }
        
        typeStats[category].events++;
        typeStats[category].totalSales += event.actualSales || 0;
    });
    
    return Object.entries(typeStats)
        .map(([type, stats]) => ({
            type,
            avgSales: stats.events > 0 ? stats.totalSales / stats.events : 0,
            events: stats.events
        }))
        .sort((a, b) => b.avgSales - a.avgSales);
}

function calculateROI(event) {
    if (!event.actualSales) return null;
    
    const financials = estimateEventFinancials(event.actualSales, event);
    const investment = financials.totalCosts;
    
    if (investment <= 0) return null;
    
    return ((financials.profit / investment) * 100);
}

function findSimilarEvents(targetEvent) {
    const similarityThreshold = 0.3;
    
    return historicalData.filter(event => {
        let similarity = 0;
        let factors = 0;
        
        // Compare event type
        if (event.category === targetEvent.eventType) {
            similarity += 0.4;
        }
        factors++;
        
        // Compare location
        if (event.location === targetEvent.location) {
            similarity += 0.3;
        }
        factors++;
        
        // Compare size (attendance)
        const attendanceDiff = Math.abs((event.attendance || 0) - (targetEvent.expectedVisitors || 0));
        const maxAttendance = Math.max(event.attendance || 0, targetEvent.expectedVisitors || 0);
        if (maxAttendance > 0) {
            const attendanceSimilarity = 1 - (attendanceDiff / maxAttendance);
            similarity += attendanceSimilarity * 0.3;
        }
        factors++;
        
        return (similarity / factors) >= similarityThreshold;
    });
}

console.log('üìù ƒå√°st 10 naƒçtena - Analytics a trendy'); style="color: #27ae60;">ü•á Top 5 nejlep≈°√≠ch akc√≠</h4>
    `;
    
    performance.topPerformers.slice(0, 5).forEach((event, index) => {
        html += `
            <div style="background: #f8f9fa; padding: 10px; border-radius: 6px; margin: 8px 0; border-left: 4px solid #27ae60;">
                <strong>${index + 1}. ${event.eventName || 'Bez n√°zvu'}</strong>
                <div style="font-size: 0.9em; color: #7f8c8d;">
                    üìä ${(event.actualSales || 0).toLocaleString('cs-CZ')} ks | 
                    üìç ${event.location || 'Nezn√°m√°'} | 
                    üìÖ ${new Date(event.eventDate || event.date).toLocaleDateString('cs-CZ')}
                </div>
            </div>
        `;
    });
    
    html += `
                </div>
                <div>
                    <h4 style="color: #e74c3c;">üìâ Nejslab≈°√≠ akce</h4>
    `;
    
    performance.underPerformers.forEach((event, index) => {
        html += `
            <div style="background: #f8f9fa; padding: 10px; border-radius: 6px; margin: 8px 0; border-left: 4px solid #e74c3c;">
                <strong>${event.eventName || 'Bez n√°zvu'}</strong>
                <div style="font-size: 0.9em; color: #7f8c8d;">
                    üìä ${(event.actualSales || 0).toLocaleString('cs-CZ')} ks | 
                    üìç ${event.location || 'Nezn√°m√°'} | 
                    üìÖ ${new Date(event.eventDate || event.date).toLocaleDateString('cs-CZ')}
                </div>
            </div>
        `;
    });
    
    html += `
                </div>
            </div>
        </div>
    `;
    
    return html;
}

function createPredictionAccuracySection(predictions) {
    if (predictions.totalComparisons === 0) {
        return `
            <div class="form-section">
                <h3>üéØ P≈ôesnost predikce</h3>
                <p style="text-align: center; color: #7f8c8d;">Zat√≠m nejsou dostupn√° data pro porovn√°n√≠ predikce se skuteƒçnost√≠.</p>
            </div>
        `;
    }
    
    return `
        <div class="form-section">
            <h3>üéØ P≈ôesnost predikce</h3>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px;">
                <div style="background: #3498db; color: white; padding: 15px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 1.5em; font-weight: bold;">${predictions.accuracy.toFixed(1)}%</div>
                    <div>Pr≈Ømƒõrn√° p≈ôesnost</div>
                </div>
                <div style="background: #f39c12; color: white; padding: 15px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 1.5em; font-weight: bold;">${Math.round(predictions.avgError).toLocaleString('cs-CZ')}</div>
                    <div>Pr≈Ømƒõrn√° chyba (ks)</div>
                </div>
                <div style="background: #9b59b6; color: white; padding: 15px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 1.5em; font-weight: bold;">${predictions.totalComparisons}</div>
                    <div>Porovn√°n√≠ celkem</div>
                </div>
            </div>
            
            <h4>üèÖ Nejp≈ôesnƒõj≈°√≠ predikce</h4>
            ${predictions.bestPredictions.slice(0, 3).map(event => `
                <div style="background: #d4edda; padding: 10px; border-radius: 6px; margin: 8px 0;">
                    <strong>${event.eventName || 'Bez n√°zvu'}</strong>
                    <div style="font-size: 0.9em; color: #155724;">
                        P≈ôesnost: ${event.accuracy.toFixed(1)}% | 
                        Predikce: ${event.estimatedSales.toLocaleString('cs-CZ')} ks | 
                        Skuteƒçnost: ${event.actualSales.toLocaleString('cs-CZ')} ks
                    </div>
                </div>
            `).join('')}
        </div>
    `;
}

function createProfitabilitySection(profitability) {
    return `
        <div class="form-section">
            <h3>üí∞ Ziskovost</h3>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px;">
                <div style="background: ${profitability.profitabilityRate >= 70 ? '#27ae60' : profitability.profitabilityRate >= 50 ? '#f39c12' : '#e74c3c'}; color: white; padding: 15px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 1.5em; font-weight: bold;">${profitability.profitabilityRate.toFixed(1)}%</div>
                    <div>M√≠ra ziskovosti</div>
                </div>
                <div style="background: #27ae60; color: white; padding: 15px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 1.5em; font-weight: bold;">${profitability.totalProfitable}</div>
                    <div>Ziskov√© akce</div>
                </div>
                <div style="background: #e74c3c; color: white; padding: 15px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 1.5em; font-weight: bold;">${profitability.totalUnprofitable}</div>
                    <div>Ztr√°tov√© akce</div>
                </div>
            </div>
            
            <h4
            // ƒå√ÅST 11: NASTAVEN√ç A AUTOCOMPLETE SYST√âM
// P≈ôidejte tuto ƒç√°st za ƒå√°st 10 v <script> tagu

// =============================================================================
// SETTINGS MANAGEMENT
// =============================================================================

function loadSettings() {
    console.log('‚öôÔ∏è Loading settings...');
    
    const saved = localStorage.getItem('donulandSettings');
    let settings = {};
    
    if (saved) {
        try {
            settings = JSON.parse(saved);
        } catch (e) {
            console.error('Error loading settings:', e);
            settings = {};
        }
    }
    
    // Apply default values if not set
    const defaults = getDefaultSettings();
    settings = { ...defaults, ...settings };
    
    // Update UI with loaded settings
    updateSettingsUI(settings);
    
    // Update current calculations display
    updateCurrentCalculations(settings);
    
    console.log('‚úÖ Settings loaded:', settings);
}

function getDefaultSettings() {
    return {
        defaultDonutPrice: 110,
        defaultDonutCost: 32,
        franchiseDonutPrice: 52,
        defaultTransportRate: 10,
        qualityTempThreshold: 28,
        defaultEventDuration: 2,
        safetyBuffer: 15,
        autoRefreshWeather: true,
        enableNotifications: true,
        defaultBusinessModel: 'owner',
        autoBackupInterval: 5, // minutes
        displayCurrency: 'CZK',
        dateFormat: 'cs-CZ',
        theme: 'default'
    };
}

function updateSettingsUI(settings) {
    const settingsFields = [
        'defaultDonutPrice',
        'defaultDonutCost', 
        'franchiseDonutPrice',
        'defaultTransportRate',
        'qualityTempThreshold',
        'defaultEventDuration'
    ];
    
    settingsFields.forEach(field => {
        const element = document.getElementById(field);
        if (element && settings[field] !== undefined) {
            element.value = settings[field];
        }
    });
    
    // Update safety buffer in weekly planning
    const safetyBufferElement = document.getElementById('safetyBuffer');
    if (safetyBufferElement && settings.safetyBuffer !== undefined) {
        safetyBufferElement.value = settings.safetyBuffer;
    }
}

function saveSettings() {
    try {
        const settings = {
            defaultDonutPrice: parseFloat(document.getElementById('defaultDonutPrice')?.value) || 110,
            defaultDonutCost: parseFloat(document.getElementById('defaultDonutCost')?.value) || 32,
            franchiseDonutPrice: parseFloat(document.getElementById('franchiseDonutPrice')?.value) || 52,
            defaultTransportRate: parseFloat(document.getElementById('defaultTransportRate')?.value) || 10,
            qualityTempThreshold: parseInt(document.getElementById('qualityTempThreshold')?.value) || 28,
            defaultEventDuration: parseInt(document.getElementById('defaultEventDuration')?.value) || 2,
            safetyBuffer: parseFloat(document.getElementById('safetyBuffer')?.value) || 15,
            lastSaved: new Date().toISOString()
        };
        
        localStorage.setItem('donulandSettings', JSON.stringify(settings));
        
        // Update current calculations
        updateCurrentCalculations(settings);
        
        // Update default values in forms
        updateFormDefaults(settings);
        
        showMessage('Nastaven√≠ bylo √∫spƒõ≈°nƒõ ulo≈æeno', 'success');
        console.log('‚úÖ Settings saved:', settings);
        
    } catch (error) {
        console.error('Settings save error:', error);
        showMessage('Chyba p≈ôi ukl√°d√°n√≠ nastaven√≠', 'error');
    }
}

function resetToDefaults() {
    if (confirm('Opravdu chcete obnovit v≈°echna nastaven√≠ na v√Ωchoz√≠ hodnoty?')) {
        const defaults = getDefaultSettings();
        
        localStorage.setItem('donulandSettings', JSON.stringify(defaults));
        updateSettingsUI(defaults);
        updateCurrentCalculations(defaults);
        updateFormDefaults(defaults);
        
        showMessage('Nastaven√≠ bylo obnoveno na v√Ωchoz√≠ hodnoty', 'success');
    }
}

function updateCurrentCalculations(settings) {
    const regularMargin = settings.defaultDonutPrice - settings.defaultDonutCost;
    const franchiseMargin = settings.franchiseDonutPrice - settings.defaultDonutCost;
    const franchiseeMargin = settings.defaultDonutPrice - settings.franchiseDonutPrice;
    
    const elements = {
        regularMargin: `${regularMargin} Kƒç`,
        franchiseMargin: `${franchiseMargin} Kƒç`,
        franchiseeMargin: `${franchiseeMargin} Kƒç`,
        transportExample: `~${Math.round(410 * settings.defaultTransportRate)} Kƒç`
    };
    
    Object.entries(elements).forEach(([id, value]) => {
        const element = document.getElementById(id);
        if (element) {
            element.textContent = value;
        }
    });
}

function updateFormDefaults(settings) {
    // Update prediction form defaults
    const sellingPriceInput = document.getElementById('sellingPrice');
    if (sellingPriceInput) {
        sellingPriceInput.value = settings.defaultDonutPrice;
    }
    
    const donutCostInput = document.getElementById('donutCost');
    if (donutCostInput) {
        const businessModel = document.querySelector('input[name="businessModel"]:checked')?.value || 'owner';
        if (businessModel === 'franchisee') {
            donutCostInput.value = settings.franchiseDonutPrice;
        } else {
            donutCostInput.value = settings.defaultDonutCost;
        }
    }
    
    const durationInput = document.getElementById('eventDuration');
    if (durationInput) {
        durationInput.value = settings.defaultEventDuration;
    }
}

function exportSettings() {
    try {
        const settings = JSON.parse(localStorage.getItem('donulandSettings') || '{}');
        const settingsText = `DONULAND - NASTAVEN√ç SYST√âMU
Datum exportu: ${new Date().toLocaleString('cs-CZ')}

CENOV√â NASTAVEN√ç:
- V√Ωchoz√≠ prodejn√≠ cena donutu: ${settings.defaultDonutPrice || 110} Kƒç
- N√°klady na v√Ωrobu donutu: ${settings.defaultDonutCost || 32} Kƒç
- Prodejn√≠ cena fran≈°√≠zant≈Øm: ${settings.franchiseDonutPrice || 52} Kƒç

PROVOZN√ç NASTAVEN√ç:
- N√°klady na dopravu: ${settings.defaultTransportRate || 10} Kƒç/km
- Teplotn√≠ pr√°h pro kvalitu: ${settings.qualityTempThreshold || 28}¬∞C

KALKULACE:
- Mar≈æe na donut (bƒõ≈æn√Ω prodej): ${((settings.defaultDonutPrice || 110) - (settings.defaultDonutCost || 32))} Kƒç
- Mar≈æe na donut (fran≈°√≠za): ${((settings.franchiseDonutPrice || 52) - (settings.defaultDonutCost || 32))} Kƒç
- Fran≈°√≠zantova mar≈æe: ${((settings.defaultDonutPrice || 110) - (settings.franchiseDonutPrice || 52))} Kƒç
`;
        
        const blob = new Blob([settingsText], { type: 'text/plain;charset=utf-8;' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = `donuland_nastaveni_${new Date().toISOString().split('T')[0]}.txt`;
        link.click();
        
        showMessage('Nastaven√≠ bylo exportov√°no', 'success');
    } catch (error) {
        console.error('Export settings error:', error);
        showMessage('Chyba p≈ôi exportu nastaven√≠', 'error');
    }
}

function setDefaultSettings() {
    const defaults = getDefaultSettings();
    localStorage.setItem('donulandSettings', JSON.stringify(defaults));
    updateSettingsUI(defaults);
    updateCurrentCalculations(defaults);
}

// =============================================================================
// AUTOCOMPLETE SYSTEM
// =============================================================================

function initializeAutocomplete() {
    console.log('üîç Initializing autocomplete system...');
    
    updateAutocompleteData();
    
    // Setup event listeners for autocomplete inputs
    const eventNameInput = document.getElementById('eventName');
    const locationInput = document.getElementById('eventLocation');
    
    if (eventNameInput) {
        eventNameInput.addEventListener('input', handleEventNameInput);
        eventNameInput.addEventListener('keydown', handleAutocompleteKeydown);
        eventNameInput.addEventListener('blur', hideAutocomplete);
    }
    
    if (locationInput) {
        locationInput.addEventListener('input', handleLocationInput);
        locationInput.addEventListener('keydown', handleAutocompleteKeydown);
        locationInput.addEventListener('blur', hideAutocomplete);
    }
    
    console.log('‚úÖ Autocomplete initialized');
}

function updateAutocompleteData() {
    // Collect unique event names from all sources
    const allEvents = [...historicalData, ...plannedEvents, ...localSavedEvents];
    
    autocompleteData.eventNames = [...new Set(
        allEvents
            .map(event => event.eventName)
            .filter(name => name && name.trim().length > 0)
    )].sort();
    
    // Collect unique locations
    autocompleteData.locations = [...new Set(
        allEvents
            .map(event => event.location)
            .filter(location => location && location.trim().length > 0)
    )].sort();
    
    // Add common Czech cities
    const czechCities = [
        'Praha', 'Brno', 'Ostrava', 'Plze≈à', 'Liberec', 'Olomouc', '√öst√≠ nad Labem',
        'ƒåesk√© Budƒõjovice', 'Hradec Kr√°lov√©', 'Pardubice', 'Zl√≠n', 'Hav√≠≈ôov',
        'Kladno', 'Most', 'Opava', 'Fr√Ωdek-M√≠stek', 'Karvin√°', 'Jihlava',
        'Teplice', 'Dƒõƒç√≠n', 'Karlovy Vary', 'Jablonec nad Nisou', 'Mlad√° Boleslav'
    ];
    
    czechCities.forEach(city => {
        if (!autocompleteData.locations.includes(city)) {
            autocompleteData.locations.push(city);
        }
    });
    
    autocompleteData.locations.sort();
    
    console.log('üìù Autocomplete data updated:', {
        eventNames: autocompleteData.eventNames.length,
        locations: autocompleteData.locations.length
    });
}

// === OPRAVA NA≈†EPT√ÅVAƒå≈Æ (AUTOCOMPLETE) ===
function handleEventNameInput() {
    const input = document.getElementById('eventName');
    if (!input) {
        console.error('Event name input not found');
        return;
    }
    
    const query = input.value.trim().toLowerCase();
    
    if (query.length < 2) {
        hideAutocompleteImproved();
        return;
    }
    
    // Aktualizovat autocomplete data pokud nejsou naƒçtena
    if (!autocompleteData.eventNames || autocompleteData.eventNames.length === 0) {
        updateAutocompleteDataImproved();
    }
    
    const matches = autocompleteData.eventNames.filter(name =>
        name.toLowerCase().includes(query)
    ).slice(0, 8);
    
    console.log(`üîç Event name autocomplete: "${query}" -> ${matches.length} matches`);
    
    if (matches.length > 0) {
        showAutocompleteImproved(input, matches, 'eventName');
    } else {
        hideAutocompleteImproved();
    }
}

function handleLocationInput() {
    const input = document.getElementById('eventLocation');
    if (!input) {
        console.error('Location input not found');
        return;
    }
    
    const query = input.value.trim().toLowerCase();
    
    if (query.length < 1) {
        hideAutocompleteImproved();
        return;
    }
    
    // Aktualizovat autocomplete data pokud nejsou naƒçtena
    if (!autocompleteData.locations || autocompleteData.locations.length === 0) {
        updateAutocompleteDataImproved();
    }
    
    const matches = autocompleteData.locations.filter(location =>
        location.toLowerCase().includes(query)
    ).slice(0, 10);
    
    console.log(`üîç Location autocomplete: "${query}" -> ${matches.length} matches`);
    
    if (matches.length > 0) {
        showAutocompleteImproved(input, matches, 'location');
        
        // Enhanced location validation po kr√°tk√©m zpo≈ædƒõn√≠
        setTimeout(() => {
            enhancedLocationValidationImproved();
        }, 150);
    } else {
        hideAutocompleteImproved();
    }
}

// Vylep≈°en√° funkce pro aktualizaci autocomplete dat
function updateAutocompleteDataImproved() {
    console.log('üîÑ Updating autocomplete data...');
    
    // Inicializovat pokud neexistuje
    if (!autocompleteData) {
        autocompleteData = { eventNames: [], locations: [] };
    }
    
    // Shrom√°≈ædit unique n√°zvy akc√≠ ze v≈°ech zdroj≈Ø
    const allEvents = [
        ...(historicalData || []),
        ...(plannedEvents || []),
        ...(localSavedEvents || [])
    ];
    
    autocompleteData.eventNames = [...new Set(
        allEvents
            .map(event => event.eventName)
            .filter(name => name && name.trim().length > 0)
            .map(name => name.trim())
    )].sort();
    
    // Shrom√°≈ædit unique lokality
    autocompleteData.locations = [...new Set(
        allEvents
            .map(event => event.location)
            .filter(location => location && location.trim().length > 0)
            .map(location => location.trim())
    )].sort();
    
    // P≈ôidat bƒõ≈æn√° ƒçesk√° mƒõsta
    const czechCities = [
        'Praha', 'Brno', 'Ostrava', 'Plze≈à', 'Liberec', 'Olomouc', '√öst√≠ nad Labem',
        'ƒåesk√© Budƒõjovice', 'Hradec Kr√°lov√©', 'Pardubice', 'Zl√≠n', 'Hav√≠≈ôov',
        'Kladno', 'Most', 'Opava', 'Fr√Ωdek-M√≠stek', 'Karvin√°', 'Jihlava',
        'Teplice', 'Dƒõƒç√≠n', 'Karlovy Vary', 'Jablonec nad Nisou', 'Mlad√° Boleslav',
        'Prostƒõjov', 'P≈ôerov', 'ƒåesk√° L√≠pa', 'T≈ôinec', 'T√°bor', 'Znojmo'
    ];
    
    czechCities.forEach(city => {
        if (!autocompleteData.locations.includes(city)) {
            autocompleteData.locations.push(city);
        }
    });
    
    autocompleteData.locations.sort();
    
    console.log('üìù Autocomplete data updated:', {
        eventNames: autocompleteData.eventNames.length,
        locations: autocompleteData.locations.length
    });
}

// Vylep≈°en√° funkce pro zobrazen√≠ autocomplete
function showAutocompleteImproved(input, matches, type) {
    // Odstranit existuj√≠c√≠ dropdown
    hideAutocompleteImproved();
    
    const dropdown = document.createElement('div');
    dropdown.className = 'autocomplete-dropdown';
    dropdown.id = 'autocompleteDropdown';
    dropdown.style.cssText = `
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        background: white;
        border: 1px solid #ddd;
        border-top: none;
        border-radius: 0 0 8px 8px;
        max-height: 200px;
        overflow-y: auto;
        z-index: 1000;
        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    `;
    
    matches.forEach((match, index) => {
        const item = document.createElement('div');
        item.className = 'autocomplete-item';
        item.style.cssText = `
            padding: 10px 15px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
            transition: background-color 0.2s;
        `;
        
        // Z√°kladn√≠ text
        const mainText = document.createElement('div');
        mainText.style.fontWeight = '500';
        mainText.textContent = match;
        item.appendChild(mainText);
        
        // P≈ôidat dodateƒçn√© informace pro n√°zvy akc√≠
        if (type === 'eventName') {
            const relatedEvents = findRelatedEventsImproved(match);
            if (relatedEvents.length > 0) {
                const lastEvent = relatedEvents[relatedEvents.length - 1];
                const additionalInfo = document.createElement('div');
                additionalInfo.style.cssText = `
                    font-size: 0.8em; 
                    color: #7f8c8d; 
                    margin-top: 2px;
                `;
                additionalInfo.textContent = `Posledn√≠: ${lastEvent.location || 'Nezn√°m√°'} (${(lastEvent.actualSales || lastEvent.predictedSales || 0).toLocaleString('cs-CZ')} ks)`;
                item.appendChild(additionalInfo);
            }
        }
        
        // Hover effects
        item.onmouseenter = () => {
            item.style.backgroundColor = '#f8f9fa';
            // Odstranit selected z ostatn√≠ch
            dropdown.querySelectorAll('.autocomplete-item').forEach(i => i.classList.remove('selected'));
            item.classList.add('selected');
        };
        
        item.onmouseleave = () => {
            item.style.backgroundColor = 'white';
        };
        
        // Click handler
        item.onclick = () => {
            input.value = match;
            hideAutocompleteImproved();
            
            // Auto-fill souvisej√≠c√≠ch dat pro n√°zvy akc√≠
            if (type === 'eventName') {
                autoFillEventDataImproved(match);
            }
            
            // Spustit change event
            input.dispatchEvent(new Event('change', { bubbles: true }));
            input.dispatchEvent(new Event('input', { bubbles: true }));
            
            // Naƒç√≠st poƒças√≠ pro lokality
            if (type === 'location') {
                setTimeout(() => {
                    loadWeather();
                }, 200);
            }
        };
        
        dropdown.appendChild(item);
    });
    
    // P≈ôidat do DOM
    const inputParent = input.parentElement;
    if (inputParent) {
        inputParent.style.position = 'relative';
        inputParent.appendChild(dropdown);
    }
}

// Vylep≈°en√° funkce pro skryt√≠ autocomplete
function hideAutocompleteImproved() {
    const dropdown = document.getElementById('autocompleteDropdown');
    if (dropdown) {
        dropdown.remove();
    }
    
    // Odstranit v≈°echny autocomplete dropdowny (pokud by jich bylo v√≠ce)
    document.querySelectorAll('.autocomplete-dropdown').forEach(d => d.remove());
}

// Vylep≈°en√° funkce pro hled√°n√≠ souvisej√≠c√≠ch akc√≠
function findRelatedEventsImproved(eventName) {
    const allEvents = [
        ...(historicalData || []),
        ...(plannedEvents || []),
        ...(localSavedEvents || [])
    ];
    
    return allEvents.filter(event => 
        event.eventName && 
        event.eventName.toLowerCase().trim() === eventName.toLowerCase().trim()
    ).sort((a, b) => {
        const dateA = new Date(a.date || a.eventDate || 0);
        const dateB = new Date(b.date || b.eventDate || 0);
        return dateA - dateB;
    });
}

// Vylep≈°en√° funkce pro auto-fill dat akc√≠
function autoFillEventDataImproved(eventName) {
    const relatedEvents = findRelatedEventsImproved(eventName);
    
    if (relatedEvents.length === 0) return;
    
    // Pou≈æ√≠t nejnovƒõj≈°√≠ akci pro auto-fill
    const latestEvent = relatedEvents[relatedEvents.length - 1];
    
    console.log('üîÑ Auto-filling event data from:', latestEvent);
    
    // Auto-fill lokality pokud je pr√°zdn√°
    const locationInput = document.getElementById('eventLocation');
    if (locationInput && !locationInput.value.trim() && latestEvent.location) {
        locationInput.value = latestEvent.location;
        locationInput.dispatchEvent(new Event('input', { bubbles: true }));
    }
    
    // Auto-fill typu akce pokud je pr√°zdn√Ω
    const typeInput = document.getElementById('eventType');
    if (typeInput && !typeInput.value && (latestEvent.category || latestEvent.eventType)) {
        typeInput.value = latestEvent.category || latestEvent.eventType;
        typeInput.dispatchEvent(new Event('change', { bubbles: true }));
    }
    
    // Auto-fill d√©lky akce
    const durationInput = document.getElementById('eventDuration');
    if (durationInput && latestEvent.duration) {
        durationInput.value = latestEvent.duration;
        durationInput.dispatchEvent(new Event('change', { bubbles: true }));
    }
    
    // Auto-fill prost≈ôed√≠ akce
    const environmentInput = document.getElementById('eventEnvironment');
    if (environmentInput && latestEvent.environment) {
        environmentInput.value = latestEvent.environment;
        environmentInput.dispatchEvent(new Event('change', { bubbles: true }));
    }
    
    // Navrhnout poƒçet n√°v≈°tƒõvn√≠k≈Ø na z√°kladƒõ historick√©ho pr≈Ømƒõru
    if (relatedEvents.length > 1) {
        const avgVisitors = relatedEvents.reduce((sum, event) => 
            sum + (event.attendance || event.expectedVisitors || 0), 0
        ) / relatedEvents.length;
        
        const visitorsInput = document.getElementById('expectedVisitors');
        if (visitorsInput && avgVisitors > 0) {
            const suggestion = Math.round(avgVisitors);
            visitorsInput.placeholder = `Obvykle: ${suggestion.toLocaleString('cs-CZ')} n√°v≈°tƒõvn√≠k≈Ø`;
            
            // Pokud je input pr√°zdn√Ω, nastavit navrhovanou hodnotu
            if (!visitorsInput.value) {
                visitorsInput.value = suggestion;
                visitorsInput.dispatchEvent(new Event('input', { bubbles: true }));
            }
        }
    }
    
    showMessage(`Automaticky vyplnƒõny √∫daje na z√°kladƒõ ${relatedEvents.length} podobn√Ωch akc√≠`, 'info');
}

// Vylep≈°en√° validace lokace
function enhancedLocationValidationImproved() {
    const locationInput = document.getElementById('eventLocation');
    if (!locationInput) return;
    
    const location = locationInput.value.trim();
    const formGroup = locationInput.parentElement;
    
    // Odstranit existuj√≠c√≠ validation t≈ô√≠dy
    formGroup.classList.remove('has-error', 'has-success', 'has-warning');
    
    if (location.length < 2) return;
    
    if (validateLocationImproved(location)) {
        formGroup.classList.add('has-success');
        setTimeout(() => {
            loadWeather(); // Auto-load poƒças√≠ pro validn√≠ ƒçesk√° mƒõsta
        }, 300);
    } else if (location.length > 3) {
        formGroup.classList.add('has-warning');
        setTimeout(() => {
            loadWeather(); // Zkusit naƒç√≠st poƒças√≠ i pro mezin√°rodn√≠ lokace
        }, 500);
    }
}

// Vylep≈°en√° validace ƒçesk√Ωch mƒõst
function validateLocationImproved(locationName) {
    const czechCities = [
        'praha', 'brno', 'ostrava', 'plzen', 'liberec', 'olomouc', 'usti nad labem',
        'ceske budejovice', 'hradec kralove', 'pardubice', 'zlin', 'havirov',
        'kladno', 'most', 'opava', 'frydek-mistek', 'karvina', 'jihlava',
        'teplice', 'decin', 'karlovy vary', 'jablonec nad nisou', 'mlada boleslav',
        'prostejov', 'prerov', 'ceska lipa', 'trinec', 'tabor', 'znojmo'
    ];
    
    const normalized = locationName.toLowerCase()
        .trim()
        .replace(/[√°√†√¢√§]/g, 'a')
        .replace(/[√©√®√™√´]/g, 'e')
        .replace(/[√≠√¨√Æ√Ø]/g, 'i')
        .replace(/[√≥√≤√¥√∂]/g, 'o')
        .replace(/[√∫√π√ª√º]/g, 'u')
        .replace(/[√Ω√ø]/g, 'y')
        .replace(/ƒç/g, 'c')
        .replace(/ƒè/g, 'd')
        .replace(/≈à/g, 'n')
        .replace(/≈ô/g, 'r')
        .replace(/≈°/g, 's')
        .replace(/≈•/g, 't')
        .replace(/≈æ/g, 'z');
    
    for (const city of czechCities) {
        if (city.includes(normalized) || normalized.includes(city)) {
            return true;
        }
    }
    
    return false;
}

// Inicializace autocomplete p≈ôi naƒçten√≠ str√°nky
document.addEventListener('DOMContentLoaded', function() {
    setTimeout(() => {
        console.log('üîç Initializing autocomplete system...');
        
        updateAutocompleteDataImproved();
        
        // Setup event listeners pro autocomplete inputy
        const eventNameInput = document.getElementById('eventName');
        const locationInput = document.getElementById('eventLocation');
        
        if (eventNameInput) {
            eventNameInput.addEventListener('input', handleEventNameInput);
            eventNameInput.addEventListener('keydown', handleAutocompleteKeydownImproved);
            eventNameInput.addEventListener('blur', () => {
                setTimeout(hideAutocompleteImproved, 200); // Delay pro click handling
            });
            console.log('‚úÖ Event name autocomplete initialized');
        }
        
        if (locationInput) {
            locationInput.addEventListener('input', handleLocationInput);
            locationInput.addEventListener('keydown', handleAutocompleteKeydownImproved);
            locationInput.addEventListener('blur', () => {
                setTimeout(hideAutocompleteImproved, 200); // Delay pro click handling
            });
            console.log('‚úÖ Location autocomplete initialized');
        }
        
        console.log('‚úÖ Autocomplete system initialized');
    }, 700);
});

// Vylep≈°en√© keyboard handling pro autocomplete
function handleAutocompleteKeydownImproved(e) {
    const dropdown = document.getElementById('autocompleteDropdown');
    if (!dropdown) return;
    
    const items = dropdown.querySelectorAll('.autocomplete-item');
    let selectedIndex = Array.from(items).findIndex(item => item.classList.contains('selected'));
    
    switch (e.key) {
        case 'ArrowDown':
            e.preventDefault();
            if (selectedIndex < items.length - 1) {
                if (selectedIndex >= 0) items[selectedIndex].classList.remove('selected');
                items[selectedIndex + 1].classList.add('selected');
                items[selectedIndex + 1].scrollIntoView({ block: 'nearest' });
            }
            break;
            
        case 'ArrowUp':
            e.preventDefault();
            if (selectedIndex > 0) {
                items[selectedIndex].classList.remove('selected');
                items[selectedIndex - 1].classList.add('selected');
                items[selectedIndex - 1].scrollIntoView({ block: 'nearest' });
            }
            break;
            
        case 'Enter':
            e.preventDefault();
            if (selectedIndex >= 0) {
                items[selectedIndex].click();
            }
            break;
            
        case 'Escape':
            hideAutocompleteImproved();
            break;
    }
}

// Click outside to hide autocomplete
document.addEventListener('click', (e) => {
    if (!e.target.closest('.form-group') && !e.target.closest('.autocomplete-dropdown')) {
        hideAutocompleteImproved();
    }
});

// =============================================================================
// SMART SUGGESTIONS SYSTEM
// =============================================================================

function generateSmartSuggestions(eventType, location, visitors) {
    const suggestions = {
        eventType: [],
        pricing: [],
        duration: [],
        logistics: []
    };
    
    // Event type suggestions
    if (eventType) {
        const similarEvents = historicalData.filter(event => 
            event.category && event.category.toLowerCase().includes(eventType.toLowerCase())
        );
        
        if (similarEvents.length > 0) {
            const avgSales = similarEvents.reduce((sum, e) => sum + (e.actualSales || 0), 0) / similarEvents.length;
            const bestEvent = similarEvents.reduce((best, current) => 
                (current.actualSales || 0) > (best.actualSales || 0) ? current : best
            );
            
            suggestions.eventType.push({
                type: 'performance',
                text: `Typ "${eventType}" m√° pr≈Ømƒõrn√Ω prodej ${Math.round(avgSales).toLocaleString('cs-CZ')} ks`,
                confidence: Math.min(95, similarEvents.length * 10)
            });
            
            if (bestEvent.location) {
                suggestions.eventType.push({
                    type: 'location',
                    text: `Nejlep≈°√≠ v√Ωsledek: ${bestEvent.location} (${(bestEvent.actualSales || 0).toLocaleString('cs-CZ')} ks)`,
                    confidence: 85
                });
            }
        }
    }
    
    // Pricing suggestions
    if (visitors > 0) {
        const optimalPrice = calculateOptimalPrice(eventType, visitors);
        if (optimalPrice) {
            suggestions.pricing.push({
                type: 'price_optimization',
                text: `Doporuƒçen√° cena: ${optimalPrice} Kƒç (optimalizov√°no pro ${visitors.toLocaleString('cs-CZ')} n√°v≈°tƒõvn√≠k≈Ø)`,
                confidence: 75
            });
        }
    }
    
    // Duration suggestions
    const durationSuggestion = suggestOptimalDuration(eventType, visitors);
    if (durationSuggestion) {
        suggestions.duration.push(durationSuggestion);
    }
    
    // Logistics suggestions
    if (location) {
        const logisticsSuggestion = generateLogisticsSuggestions(location, visitors);
        suggestions.logistics.push(...logisticsSuggestion);
    }
    
    return suggestions;
}

function calculateOptimalPrice(eventType, visitors) {
    const settings = JSON.parse(localStorage.getItem('donulandSettings') || '{}');
    const basePrice = settings.defaultDonutPrice || 110;
    
    // Price elasticity based on event size
    if (visitors > 10000) {
        return Math.round(basePrice * 0.95); // Volume discount
    } else if (visitors < 1000) {
        return Math.round(basePrice * 1.05); // Premium for small events
    }
    
    return basePrice;
}

function suggestOptimalDuration(eventType, visitors) {
    const eventDurationData = {
        'food festival': { optimal: 2, min: 1, max: 3 },
        'veletrh': { optimal: 3, min: 2, max: 5 },
        'koncert': { optimal: 1, min: 1, max: 1 },
        'sportovni': { optimal: 1, min: 1, max: 2 },
        'kulturni': { optimal: 2, min: 1, max: 3 }
    };
    
    const typeData = eventDurationData[eventType];
    if (!typeData) return null;
    
    let suggestedDuration = typeData.optimal;
    
    // Adjust based on visitor count
    if (visitors > 5000 && typeData.max > typeData.optimal) {
        suggestedDuration = Math.min(typeData.max, typeData.optimal + 1);
    }
    
    return {
        type: 'duration',
        text: `Doporuƒçen√° d√©lka: ${suggestedDuration} ${suggestedDuration === 1 ? 'den' : 'dny'} pro typ "${eventType}"`,
        confidence: 80
    };
}

function generateLogisticsSuggestions(location, visitors) {
    const suggestions = [];
    
    // Staff recommendations
    let staffCount = 2; // Default
    if (visitors > 5000) staffCount = 3;
    if (visitors > 10000) staffCount = 4;
    
    suggestions.push({
        type: 'staffing',
        text: `Doporuƒçen√© obsazen√≠: ${staffCount} lid√© pro ${visitors.toLocaleString('cs-CZ')} n√°v≈°tƒõvn√≠k≈Ø`,
        confidence: 85
    });
    
    // Transport suggestions
    const distance = estimateDistanceFromPrague(location);
    if (distance > 200) {
        suggestions.push({
            type: 'transport',
            text: `Vzd√°len√° lokalita (${distance}km) - zva≈æte p≈ôenocov√°n√≠ pro sn√≠≈æen√≠ n√°klad≈Ø`,
            confidence: 70
        });
    }
    
    return suggestions;
}

function estimateDistanceFromPrague(location) {
    const distanceMap = {
        'brno': 210,
        'ostrava': 350,
        'plzen': 90,
        'liberec': 100,
        'olomouc': 280,
        'karlovy vary': 130,
        'ceske budejovice': 150
    };
    
    const normalizedLocation = location.toLowerCase();
    for (const [city, distance] of Object.entries(distanceMap)) {
        if (normalizedLocation.includes(city)) {
            return distance;
        }
    }
    
    return 100; // Default estimate
}

function displaySmartSuggestions(suggestions) {
    // This would display suggestions in the UI
    // Implementation depends on where you want to show them
    console.log('üí° Smart suggestions:', suggestions);
}

// =============================================================================
// PREFERENCES AND USER EXPERIENCE
// =============================================================================

function saveUserPreferences() {
    const preferences = {
        lastUsedBusinessModel: document.querySelector('input[name="businessModel"]:checked')?.value,
        lastUsedLocation: document.getElementById('eventLocation')?.value,
        lastUsedEventType: document.getElementById('eventType')?.value,
        preferredCalendarView: calendarView,
        lastSafetyBuffer: document.getElementById('safetyBuffer')?.value,
        timestamp: new Date().toISOString()
    };
    
    localStorage.setItem('donulandPreferences', JSON.stringify(preferences));
}

function loadUserPreferences() {
    const saved = localStorage.getItem('donulandPreferences');
    if (!saved) return;
    
    try {
        const preferences = JSON.parse(saved);
        
        // Restore business model
        if (preferences.lastUsedBusinessModel) {
            const radio = document.querySelector(`input[name="businessModel"][value="${preferences.lastUsedBusinessModel}"]`);
            if (radio) {
                radio.checked = true;
                updateBusinessModelInfo();
            }
        }
        
        // Restore calendar view
        if (preferences.preferredCalendarView) {
            calendarView = preferences.preferredCalendarView;
        }
        
        console.log('‚úÖ User preferences loaded');
    } catch (e) {
        console.error('Error loading preferences:', e);
    }
}

function setupEventListeners() {
    const inputs = [
        'eventType', 'eventName', 'expectedVisitors', 'eventEnvironment',
        'donutCost', 'sellingPrice', 'otherCosts',
        'fixedRental', 'percentageRental'
    ];
    
    inputs.forEach(id => {
        const element = document.getElementById(id);
        if (element) {
            element.addEventListener('change', updatePrediction);
            element.addEventListener('input', debounce(updatePrediction, 500));
            element.addEventListener('blur', saveUserPreferences);
        }
    });

    document.querySelectorAll('input[name="businessModel"]').forEach(radio => {
        radio.addEventListener('change', () => {
            updateBusinessModelInfo();
            updatePrediction();
            saveUserPreferences();
        });
    });
}

console.log('üìù ƒå√°st 11 naƒçtena - Nastaven√≠ a autocomplete syst√©m');
    // ƒå√ÅST 12: BACKUP SYST√âM A FIN√ÅLN√ç INICIALIZACE
// P≈ôidejte tuto ƒç√°st za ƒå√°st 11 v <script> tagu

// =============================================================================
// BACKUP AND SYSTEM FUNCTIONS
// =============================================================================

function createManualBackup() {
    try {
        const backupData = {
            timestamp: new Date().toISOString(),
            version: '2.1',
            type: 'manual',
            localEvents: localSavedEvents,
            historicalData: historicalData.length > 0 ? historicalData.slice(0, 100) : [],
            settings: JSON.parse(localStorage.getItem('donulandSettings') || '{}'),
            preferences: JSON.parse(localStorage.getItem('donulandPreferences') || '{}'),
            systemInfo: {
                userAgent: navigator.userAgent,
                timestamp: new Date().toISOString(),
                totalEvents: localSavedEvents.length,
                historicalCount: historicalData.length
            }
        };
        
        const blob = new Blob([JSON.stringify(backupData, null, 2)], { 
            type: 'application/json;charset=utf-8;' 
        });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = `donuland_backup_${new Date().toISOString().split('T')[0]}.json`;
        link.click();
        
        // Save backup info
        localStorage.setItem('donulandLastManualBackup', new Date().toISOString());
        updateLastBackupInfo();
        
        showMessage('Z√°loha byla vytvo≈ôena a sta≈æena', 'success');
        console.log('‚úÖ Manual backup created');
        
    } catch (error) {
        console.error('Backup error:', error);
        showMessage('Chyba p≈ôi vytv√°≈ôen√≠ z√°lohy', 'error');
    }
}

function restoreFromBackup() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    input.onchange = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const backupData = JSON.parse(e.target.result);
                
                if (!backupData.version || !backupData.timestamp) {
                    throw new Error('Neplatn√Ω form√°t z√°lohy');
                }
                
                const backupDate = new Date(backupData.timestamp).toLocaleString('cs-CZ');
                const confirmMessage = `Obnovit z√°lohu z ${backupDate}?\n\nZ√°loha obsahuje:\n- ${backupData.localEvents?.length || 0} lok√°ln√≠ch akc√≠\n- ${backupData.historicalData?.length || 0} historick√Ωch z√°znam≈Ø\n- Nastaven√≠ a preference\n\nV≈°echna souƒçasn√° data budou p≈ôeps√°na!`;
                
                if (!confirm(confirmMessage)) {
                    return;
                }
                
                // Restore local events
                if (backupData.localEvents) {
                    localSavedEvents = backupData.localEvents;
                    localStorage.setItem('donulandEvents', JSON.stringify(localSavedEvents));
                }
                
                // Restore settings
                if (backupData.settings) {
                    localStorage.setItem('donulandSettings', JSON.stringify(backupData.settings));
                    loadSettings();
                }
                
                // Restore preferences
                if (backupData.preferences) {
                    localStorage.setItem('donulandPreferences', JSON.stringify(backupData.preferences));
                    loadUserPreferences();
                }
                
                // Update autocomplete data
                updateAutocompleteData();
                
                // Refresh current view
                if (calendarView === 'month') {
                    renderCalendar();
                } else {
                    renderEventList();
                }
                
                const weeklyTab = document.getElementById('weekly');
                if (weeklyTab && weeklyTab.classList.contains('active')) {
                    calculateWeeklyPlan();
                }
                
                // Clear any existing predictions
                lastPrediction = null;
                document.getElementById('predictionResults').innerHTML = 
                    '<div class="prediction-loading">üìç Vypl≈àte typ akce a n√°v≈°tƒõvnost pro naƒçten√≠ predikce</div>';
                
                showMessage(`Z√°loha z ${backupDate} byla √∫spƒõ≈°nƒõ obnovena`, 'success');
                console.log('‚úÖ Backup restored:', backupData.systemInfo);
                
            } catch (error) {
                console.error('Restore error:', error);
                showMessage('Chyba p≈ôi obnoven√≠ ze z√°lohy: ' + error.message, 'error');
            }
        };
        reader.readAsText(file);
    };
    input.click();
}

function clearAllData() {
    if (confirm('‚ö†Ô∏è VAROV√ÅN√ç: Tato akce sma≈æe v≈°echna data vƒçetnƒõ ulo≈æen√Ωch akc√≠, nastaven√≠ a z√°loh. Tuto akci nelze vr√°tit zpƒõt.\n\nOpravdu chcete pokraƒçovat?')) {
        if (confirm('Jste si jist√≠? V≈°echna data budou TRVALE ZTRACENA!')) {
            try {
                const keysToRemove = [
                    'donulandEvents',
                    'donulandSettings',
                    'donulandPreferences',
                    'donulandFormDraft',
                    'donulandAutoBackup',
                    'donulandLastBackup',
                    'donulandLastManualBackup',
                    'donulandErrors',
                    'donulandLastDataLoad'
                ];
                
                keysToRemove.forEach(key => {
                    localStorage.removeItem(key);
                });
                
                // Reset global variables
                localSavedEvents = [];
                historicalData = [];
                plannedEvents = [];
                lastPrediction = null;
                currentWeatherData = null;
                autocompleteData = { eventNames: [], locations: [] };
                
                // Reset to default settings
                setDefaultSettings();
                
                // Clear forms
                document.getElementById('predictionResults').innerHTML = 
                    '<div class="prediction-loading">üìç Vypl≈àte typ akce a n√°v≈°tƒõvnost pro naƒçten√≠ predikce</div>';
                
                const form = document.querySelector('#prediction');
                if (form) {
                    const inputs = form.querySelectorAll('input, select');
                    inputs.forEach(input => {
                        if (input.type === 'radio') {
                            input.checked = input.value === 'owner';
                        } else if (input.type === 'date') {
                            const tomorrow = new Date();
                            tomorrow.setDate(tomorrow.getDate() + 1);
                            input.value = tomorrow.toISOString().split('T')[0];
                        } else if (input.tagName === 'SELECT') {
                            input.selectedIndex = 0;
                        } else {
                            input.value = '';
                        }
                    });
                }
                
                // Refresh views
                if (calendarView === 'month') {
                    renderCalendar();
                } else {
                    renderEventList();
                }
                
                // Reset analytics
                loadAnalytics();
                
                showMessage('V≈°echna data byla vymaz√°na. Aplikace byla resetov√°na.', 'warning');
                console.log('üóëÔ∏è All data cleared - system reset');
                
            } catch (error) {
                console.error('Clear data error:', error);
                showMessage('Chyba p≈ôi maz√°n√≠ dat: ' + error.message, 'error');
            }
        }
    }
}

function showSystemDiagnostics() {
    const diagnosticsHTML = `
        <div style="max-height: 500px; overflow-y: auto;">
            <h4 style="color: #2c3e50; margin-bottom: 15px;">üîç Syst√©mov√° diagnostika</h4>
            
            <div style="display: grid; gap: 15px;">
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px;">
                    <h5 style="margin: 0 0 10px 0; color: #34495e;">üíª Syst√©mov√© informace</h5>
                    <div style="font-size: 0.9em; line-height: 1.6;">
                        <div><strong>Prohl√≠≈æeƒç:</strong> ${navigator.userAgent.split('(')[0].trim()}</div>
                        <div><strong>Platforma:</strong> ${navigator.platform}</div>
                        <div><strong>Jazyk:</strong> ${navigator.language}</div>
                        <div><strong>Online:</strong> ${navigator.onLine ? 'Ano' : 'Ne'}</div>
                        <div><strong>LocalStorage:</strong> ${typeof(Storage) !== "undefined" ? 'Podporov√°no' : 'Nen√≠ podporov√°no'}</div>
                        <div><strong>Velikost LocalStorage:</strong> ${calculateStorageSize()} KB</div>
                    </div>
                </div>
                
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px;">
                    <h5 style="margin: 0 0 10px 0; color: #34495e;">üìä Stav dat</h5>
                    <div style="font-size: 0.9em; line-height: 1.6;">
                        <div><strong>Historick√© akce:</strong> ${historicalData.length}</div>
                        <div><strong>Pl√°novan√© akce:</strong> ${plannedEvents.length}</div>
                        <div><strong>Lok√°ln√≠ akce:</strong> ${localSavedEvents.length}</div>
                        <div><strong>Autocomplet n√°zvy:</strong> ${autocompleteData.eventNames.length}</div>
                        <div><strong>Autocomplet lokality:</strong> ${autocompleteData.locations.length}</div>
                        <div><strong>Posledn√≠ho naƒçten√≠ dat:</strong> ${localStorage.getItem('donulandLastDataLoad') || 'Nikdy'}</div>
                    </div>
                </div>
                
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px;">
                    <h5 style="margin: 0 0 10px 0; color: #34495e;">üåê API Status</h5>
                    <div style="font-size: 0.9em; line-height: 1.6;">
                        <div><strong>Weather API:</strong> ${WEATHER_API_KEY ? '‚úÖ Nakonfigurov√°no' : '‚ùå Chyb√≠ kl√≠ƒç'}</div>
                        <div><strong>Google Maps API:</strong> ${GOOGLE_MAPS_API_KEY ? '‚úÖ Nakonfigurov√°no' : '‚ùå Chyb√≠ kl√≠ƒç'}</div>
                        <div><strong>Google Maps naƒçteno:</strong> ${googleMapsLoaded ? '‚úÖ Ano' : '‚ùå Ne'}</div>
                        <div><strong>Sheet ID:</strong> ${SHEET_ID ? '‚úÖ Nakonfigurov√°no' : '‚ùå Chyb√≠'}</div>
                    </div>
                </div>
                
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px;">
                    <h5 style="margin: 0 0 10px 0; color: #34495e;">‚öôÔ∏è Aplikaƒçn√≠ stav</h5>
                    <div style="font-size: 0.9em; line-height: 1.6;">
                        <div><strong>Verze:</strong> 2.1</div>
                        <div><strong>Souƒçasn√Ω tab:</strong> ${document.querySelector('.nav-tab.active')?.textContent || 'Nezn√°m√Ω'}</div>
                        <div><strong>Kalend√°≈ôov√Ω pohled:</strong> ${calendarView}</div>
                        <div><strong>Aktu√°ln√≠ predikce:</strong> ${lastPrediction ? 'Naƒçtena' : '≈Ω√°dn√°'}</div>
                        <div><strong>Poƒças√≠ naƒçteno:</strong> ${currentWeatherData ? 'Ano' : 'Ne'}</div>
                    </div>
                </div>
                
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px;">
                    <h5 style="margin: 0 0 10px 0; color: #34495e;">üíæ Z√°lohy</h5>
                    <div style="font-size: 0.9em; line-height: 1.6;">
                        <div><strong>Posledn√≠ auto z√°loha:</strong> ${localStorage.getItem('donulandLastBackup') || 'Nikdy'}</div>
                        <div><strong>Posledn√≠ manu√°ln√≠ z√°loha:</strong> ${localStorage.getItem('donulandLastManualBackup') || 'Nikdy'}</div>
                        <div><strong>Auto z√°loha dostupn√°:</strong> ${localStorage.getItem('donulandAutoBackup') ? 'Ano' : 'Ne'}</div>
                    </div>
                </div>
            </div>
            
            <div style="margin-top: 20px; text-align: center;">
                <button class="btn btn-primary" onclick="closeEventModal()">‚úñÔ∏è Zav≈ô√≠t</button>
                <button class="btn btn-success" onclick="runSystemTest()" style="margin-left: 10px;">üß™ Test syst√©mu</button>
            </div>
        </div>
    `;
    
    showModal('Syst√©mov√° diagnostika', diagnosticsHTML);
}

function calculateStorageSize() {
    let total = 0;
    for (const key in localStorage) {
        if (localStorage.hasOwnProperty(key) && key.startsWith('donuland')) {
            total += localStorage[key].length;
        }
    }
    return Math.round(total / 1024 * 100) / 100;
}

function runSystemTest() {
    console.log('üß™ Running system test...');
    
    const tests = [
        { name: 'LocalStorage', test: () => typeof(Storage) !== "undefined" },
        { name: 'Weather API Key', test: () => !!WEATHER_API_KEY },
        { name: 'Google Maps API Key', test: () => !!GOOGLE_MAPS_API_KEY },
        { name: 'Sheet ID', test: () => !!SHEET_ID },
        { name: 'Data integrity', test: () => Array.isArray(localSavedEvents) && Array.isArray(historicalData) },
        { name: 'Settings format', test: () => {
            try {
                JSON.parse(localStorage.getItem('donulandSettings') || '{}');
                return true;
            } catch { return false; }
        }},
        { name: 'Autocomplete data', test: () => autocompleteData && Array.isArray(autocompleteData.eventNames) },
        { name: 'Calendar functions', test: () => typeof renderCalendar === 'function' },
        { name: 'Prediction system', test: () => typeof updatePrediction === 'function' },
        { name: 'Analytics system', test: () => typeof loadAnalytics === 'function' }
    ];
    
    let passed = 0;
    const results = tests.map(test => {
        try {
            const result = test.test();
            if (result) passed++;
            return { name: test.name, result, status: result ? '‚úÖ' : '‚ùå' };
        } catch (error) {
            return { name: test.name, result: false, status: '‚ùå', error: error.message };
        }
    });
    
    console.log('üß™ System test results:', results);
    
    let resultHTML = `<h4>üß™ V√Ωsledky testu syst√©mu</h4>`;
    resultHTML += `<p><strong>√öspƒõ≈°nost: ${passed}/${tests.length} (${Math.round(passed/tests.length*100)}%)</strong></p>`;
    resultHTML += `<div style="font-family: monospace; font-size: 0.9em;">`;
    
    results.forEach(result => {
        resultHTML += `<div>${result.status} ${result.name}`;
        if (result.error) {
            resultHTML += ` - ${result.error}`;
        }
        resultHTML += `</div>`;
    });
    
    resultHTML += `</div>`;
    
    showModal('Test syst√©mu', resultHTML);
    
    if (passed === tests.length) {
        showMessage('V≈°echny syst√©mov√© testy pro≈°ly √∫spƒõ≈°nƒõ', 'success');
    } else {
        showMessage(`${tests.length - passed} test≈Ø selhalo - zkontrolujte diagnostiku`, 'warning');
    }
}

function updateLastBackupInfo() {
    const infoDiv = document.getElementById('lastBackupInfo');
    
    if (infoDiv) {
        const lastBackup = localStorage.getItem('donulandLastBackup');
        const lastManualBackup = localStorage.getItem('donulandLastManualBackup');
        
        let infoText = '';
        
        if (lastBackup) {
            const backupDate = new Date(lastBackup);
            const timeDiff = (new Date() - backupDate) / (1000 * 60);
            
            let timeText;
            if (timeDiff < 1) {
                timeText = 'p≈ôed chvilkou';
            } else if (timeDiff < 60) {
                timeText = `p≈ôed ${Math.round(timeDiff)} minutami`;
            } else if (timeDiff < 1440) {
                timeText = `p≈ôed ${Math.round(timeDiff / 60)} hodinami`;
            } else {
                timeText = `p≈ôed ${Math.round(timeDiff / 1440)} dny`;
            }
            
            infoText += `üíæ Automatick√° z√°loha: ${backupDate.toLocaleString('cs-CZ')} (${timeText})`;
        }
        
        if (lastManualBackup) {
            const manualDate = new Date(lastManualBackup);
            if (infoText) infoText += '<br>';
            infoText += `üìÅ Manu√°ln√≠ z√°loha: ${manualDate.toLocaleString('cs-CZ')}`;
        }
        
        if (!infoText) {
            infoText = 'üíæ ≈Ω√°dn√© z√°lohy nenalezeny';
        }
        
        infoDiv.innerHTML = infoText;
    }
}

// =============================================================================
// FINAL INITIALIZATION
// =============================================================================

function setupEventListeners() {
    const inputs = [
        'eventType', 'eventName', 'expectedVisitors', 'eventEnvironment',
        'donutCost', 'sellingPrice', 'otherCosts',
        'fixedRental', 'percentageRental'
    ];
    
    inputs.forEach(id => {
        const element = document.getElementById(id);
        if (element) {
            element.addEventListener('change', updatePrediction);
            element.addEventListener('input', debounce(updatePrediction, 500));
        }
    });

    document.querySelectorAll('input[name="businessModel"]').forEach(radio => {
        radio.addEventListener('change', () => {
            updateBusinessModelInfo();
            updatePrediction();
        });
    });
    
    // Add rental model change listener
    const rentalModelSelect = document.getElementById('rentalModel');
    if (rentalModelSelect) {
        rentalModelSelect.addEventListener('change', updateRentalInputs);
    }
    
    // Current stock change listener
    const currentStockInput = document.getElementById('currentStock');
    if (currentStockInput) {
        currentStockInput.addEventListener('change', calculateWeeklyPlan);
        currentStockInput.addEventListener('input', debounce(calculateWeeklyPlan, 1000));
    }
    
    // Safety buffer change listener
    const safetyBufferInput = document.getElementById('safetyBuffer');
    if (safetyBufferInput) {
        safetyBufferInput.addEventListener('change', calculateWeeklyPlan);
        safetyBufferInput.addEventListener('input', debounce(calculateWeeklyPlan, 1000));
    }
}

function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

function schedulePeriodicBackup() {
    // Setup periodic backup every 5 minutes
    setInterval(() => {
        try {
            const backupData = {
                timestamp: new Date().toISOString(),
                localEvents: localSavedEvents,
                settings: JSON.parse(localStorage.getItem('donulandSettings') || '{}'),
                preferences: JSON.parse(localStorage.getItem('donulandPreferences') || '{}')
            };
            localStorage.setItem('donulandAutoBackup', JSON.stringify(backupData));
            localStorage.setItem('donulandLastBackup', new Date().toISOString());
            console.log('üíæ Auto-backup completed');
        } catch (e) {
            console.warn('Auto-backup failed:', e);
        }
    }, 5 * 60 * 1000); // Every 5 minutes
}

function initializeGoogleMaps() {
    if (googleMapsLoaded) return;
    
    const script = document.createElement('script');
    script.src = `https://maps.googleapis.com/maps/api/js?key=${GOOGLE_MAPS_API_KEY}&libraries=places&language=cs&region=CZ`;
    script.async = true;
    script.defer = true;
    script.onload = () => {
        googleMapsLoaded = true;
        console.log('‚úÖ Google Maps API loaded successfully');
    };
    script.onerror = () => {
        console.error('‚ùå Failed to load Google Maps API');
        showMessage('Chyba naƒç√≠t√°n√≠ Google Maps API', 'error');
    };
    document.head.appendChild(script);
}

// =============================================================================
// MAIN INITIALIZATION
// =============================================================================

document.addEventListener('DOMContentLoaded', function() {
    console.log('üöÄ Initializing Donuland Management System v2.1...');
    
    try {
        // Set default date to tomorrow
        const tomorrow = new Date();
        tomorrow.setDate(tomorrow.getDate() + 1);
        const dateInput = document.getElementById('eventDate');
        if (dateInput) {
            dateInput.value = tomorrow.toISOString().split('T')[0];
        }
        
        // Initialize all systems in order
        console.log('üìã Loading settings and preferences...');
        loadSettings();
        loadUserPreferences();
        
        console.log('üîç Initializing autocomplete...');
        initializeAutocomplete();
        
        console.log('üó∫Ô∏è Initializing Google Maps...');
        initializeGoogleMaps();
        
        console.log('üìä Loading initial data...');
        loadData(); // This will update autocomplete data
        
        console.log('üéõÔ∏è Setting up event listeners...');
        setupEventListeners();
        
        console.log('üîÑ Updating business model info...');
        updateBusinessModelInfo();
        
        console.log('üíæ Setting up periodic backup...');
        schedulePeriodicBackup();
        
        // Update backup info every minute
        setInterval(updateLastBackupInfo, 60 * 1000);
        updateLastBackupInfo();
        
        // Setup weather refresh for upcoming events
        if (typeof scheduleWeatherRefresh === 'function') {
            scheduleWeatherRefresh();
        }
        
        console.log('‚úÖ All systems initialized successfully');
        showMessage('Aplikace byla √∫spƒõ≈°nƒõ naƒçtena a je p≈ôipravena k pou≈æit√≠', 'success');
        
    } catch (error) {
        console.error('‚ùå Initialization error:', error);
        showMessage('Aplikace byla naƒçtena s omezenou funkcionalitou: ' + error.message, 'warning');
    }
});

// Handle page unload - save user preferences and create emergency backup
window.addEventListener('beforeunload', function(e) {
    try {
        saveUserPreferences();
        
        // Create emergency backup if there's unsaved data
        if (lastPrediction && !localSavedEvents.find(event => event.id === lastPrediction.id)) {
            const emergencyBackup = {
                timestamp: new Date().toISOString(),
                type: 'emergency',
                unsavedPrediction: lastPrediction
            };
            localStorage.setItem('donulandEmergencyBackup', JSON.stringify(emergencyBackup));
            
            e.preventDefault();
            e.returnValue = 'M√°te neulo≈æenou predikci. Opravdu chcete opustit str√°nku?';
            return e.returnValue;
        }
    } catch (error) {
        console.error('Error during page unload:', error);
    }
});

// Global error handler with automatic error reporting
window.addEventListener('error', (e) => {
    const errorInfo = {
        message: e.error?.message || 'Unknown error',
        filename: e.filename || 'Unknown file',
        lineno: e.lineno || 0,
        colno: e.colno || 0,
        timestamp: new Date().toISOString(),
        stack: e.error?.stack
    };
    
    console.error('Global error:', errorInfo);
    
    // Store error for debugging
    const existingErrors = JSON.parse(localStorage.getItem('donulandErrors') || '[]');
    existingErrors.push(errorInfo);
    
    // Keep only last 10 errors
    if (existingErrors.length > 10) {
        existingErrors.splice(0, existingErrors.length - 10);
    }
    
    localStorage.setItem('donulandErrors', JSON.stringify(existingErrors));
    
    showMessage('Do≈°lo k neoƒçek√°van√© chybƒõ. Zkuste obnovit str√°nku.', 'error');
});

// Handle online/offline status
window.addEventListener('online', () => {
    showMessage('P≈ôipojen√≠ obnoveno', 'success');
    updateSyncStatus('success', 'Online');
});

window.addEventListener('offline', () => {
    showMessage('P≈ôipojen√≠ ztraceno - pracuje se v offline re≈æimu', 'warning');
    updateSyncStatus('error', 'Offline');
});

// Click outside to hide autocomplete
document.addEventListener('click', (e) => {
    if (!e.target.closest('.form-group')) {
        document.querySelectorAll('.autocomplete-dropdown').forEach(dropdown => {
            dropdown.remove();
        });
    }
});

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
    if (e.ctrlKey || e.metaKey) {
        switch (e.key) {
            case 's':
                e.preventDefault();
                if (lastPrediction) {
                    saveCurrentPrediction();
                } else {
                    saveSettings();
                }
                break;
            case 'b':
                e.preventDefault();
                createManualBackup();
                break;
            case 'r':
                e.preventDefault();
                loadData();
                break;
        }
    }
});

console.log(`
üç© DONULAND MANAGEMENT SYSTEM v2.1 - KOMPLETN√ç
=============================================
‚úÖ Enhanced Data Loading & Sheet Integration
‚úÖ Advanced Weather API with Quality Alerts  
‚úÖ Google Maps Integration & Transport Costs
‚úÖ Smart Autocomplete & Historical Learning
‚úÖ Multi-Business Model Financial Calculations
‚úÖ Weekly Planning & Inventory Management
‚úÖ Professional Calendar with Profit Tracking
‚úÖ Comprehensive Analytics & Reporting
‚úÖ Settings Management & Backup System
‚úÖ Error Handling & Performance Monitoring

Syst√©m je plnƒõ funkƒçn√≠ a p≈ôipraven k produkci! üöÄ

Kl√°vesov√© zkratky:
- Ctrl+S: Ulo≈æit predikci/nastaven√≠
- Ctrl+B: Vytvo≈ôit z√°lohu
- Ctrl+R: Naƒç√≠st data ze Sheetu
`);

console.log('üìù ƒå√°st 12 naƒçtena - Backup syst√©m a fin√°ln√≠ inicializace');
    </script>
</body>
    
</html>
